<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sagar Manufacturers Dashboard</title>

    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

    <script type="text/javascript" src="https://code.jquery.com/jquery-3.6.0.min.js"></script> <style>
        /* ... Your existing CSS styles ... */
        body {
            font-family: sans-serif;
            margin: 0; /* Remove default body margin */
            padding: 0; /* Add padding to body */
            background-color: #FFFFFF; /* Light gray background */
            width: 100%; /* Ensure body spans the entire width */
        }

        .container {
            width: 100vw; /* Full width of the viewport */
            margin: 0 auto; /* Center the container */
            background-color: #fff; /* White background for container */
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            border-radius: 8px;
        }

        .dashboard-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 15px;
        }

        .dashboard-header img {
            height: 60px; /* Adjusted logo size */
            width: auto;
            margin-right: 15px;
        }

        .company-name {
            font-size: 1.8em; /* Larger company name */
            font-weight: bold;
            color: #000080;
            margin: 0;
        }

        .dashboard-title {
            font-size: 1.5em; /* Dashboard title size */
            margin-top: 15px;
            margin-bottom: 20px;
            color: #555;
            text-align: center;
        }


        #controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px; /* Space between controls */
            flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
        }

        /* Style for the combined layout, width, alignment, and reorder controls group */
       #layoutAndWidthControls {
            display: flex;
            align-items: center;
            gap: 15px; /* Space between the control groups */
            flex-wrap: wrap; /* Allow groups to wrap within the span */
            flex-grow: 1; /* Allow this section to grow */
       }

    /* Add this CSS inside your <style> tags */
    #layoutControlsContent > span:first-child,
    #widthControlsContent > span:first-child,
    #pdfRemarksInputContainer label,
    #alignmentControlsContent > span:first-child {
        font-weight: bold; /* Optional: Make the text bold */
        color: #0056b3; /* Example color: Dark blue */
        /* You can change #0056b3 to any color code you prefer */
    }

       /* Style for individual control groups (Layout, Width, Alignment) */
       #layoutControlsContent, #widthControlsContent, #alignmentControlsContent { /* Target the new span IDs */
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid #ccc;
            padding: 8px;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        #layoutControlsContent input[type="text"],
        #layoutControlsContent select,
        #layoutControlsContent button,
        #widthControlsContent select,
        #widthControlsContent input[type="number"],
        #widthControlsContent button,
        #alignmentControlsContent select,
        #alignmentControlsContent button { /* Added alignment controls */
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 14px;
        }
        #layoutControlsContent button, #widthControlsContent button, #alignmentControlsContent button { /* Added alignment controls button */
            cursor: pointer;
            background-color: #e0e0e0;
        }
         #layoutControlsContent button:hover, #widthControlsContent button:hover, #alignmentControlsContent button:hover { /* Added hover */
              background-color: #d5d5d5;
           }
        #widthControlsContent input[type="number"] {
            width: 60px; /* Adjust width as needed */
        }

        #fileInputContainer, #applyButtonContainer, #downloadButtons, #reorderControls { /* Included reorderControls */
            display: flex;
            align-items: center;
            gap: 10px;
        }
         #applyButtonContainer button {
              padding: 8px 15px;
              background-color: #007bff;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 14px;
           }
         #applyButtonContainer button:hover {
            background-color: #0056b3;
           }
         #downloadButtons button {
              padding: 8px 15px;
              background-color: #28a745;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 14px;
           }
          #downloadButtons button.pdf {
              background-color: #dc3545;
           }
         #downloadButtons button:hover {
              opacity: 0.9;
           }
        #reorderControls button { /* Style for reorder button */
              padding: 8px 15px;
              background-color: #ffc107; /* Yellowish */
              color: #333;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 14px;
           }
         #reorderControls button:hover {
              background-color: #e0a800;
           }

        #pdfRemarksInputContainer { /* Style for remarks input */
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px; /* Add some space above */
            width: 100%; /* Take full width */
            flex-wrap: wrap; /* Allow wrapping */
        }
        #pdfRemarksInputContainer label {
            font-weight: bold;
            font-size: 14px;
        }
        #pdfRemarksInputContainer input[type="text"] {
             flex-grow: 1; /* Allow input to take available space */
             padding: 5px;
             border: 1px solid #ccc;
             border-radius: 3px;
             font-size: 14px;
         }


       /* Container for horizontal scrolling of the table */
        #tableScrollContainer {
    overflow-x: auto; /* Enable horizontal scrolling */
    overflow-y: auto; /* Enable vertical scrolling */
    max-height: 500px; /* Set a fixed height for the container */
    border: 1px solid #ccc; /* Optional: Add a border for better visibility */
    margin-top: 20px; /* Space above the table */
    position: relative; /* Ensure proper positioning */
}

        /* Table styles */
        table {
            border-collapse: collapse;
            font-size: 14px;
            table-layout: fixed; /* Fixed layout for column widths */
            border: 1px solid black;
            width: 100%;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left; /* Default alignment */
            vertical-align: top;
            word-wrap: break-word;
            white-space: pre-wrap;
            
            text-overflow: ellipsis;
        }
         th {
              background-color: #e0f7fa; /* Light blue */
              font-weight: bold;
              position: relative;
              cursor: pointer;
           }
         th:hover {
              background-color: #b2ebf2;
           }
         th .sort-arrow {
              margin-left: 5px;
              font-size: 10px;
           }

/* Make the table header sticky */
table thead th {
    position: sticky;
    top: 0; /* Stick to the top of the container */
    z-index: 2; /* Ensure it stays above the table rows */
    background-color: #e0f7fa; /* Match the header background color */
    border: 1px solid black; /* Match the border style */
}
        .filter-container {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Space between filter dropdowns */
        }
        .filter-dropdown {
            position: relative;
            display: inline-block;
            vertical-align: top;
        }
        .dropdown-button {
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #007bff; /* Blue border */
            background-color: #007bff; /* Blue background */
            color: white; /* White text */
            border-radius: 4px;
            min-width: 120px;
            text-align: left;
            font-size: 14px;
        }
         .dropdown-button .filter-arrow {
              float: right;
              color: white; /* White arrow */
           }
          .dropdown-button:hover {
              background-color: #0056b3; /* Darker blue on hover */
              border-color: #0056b3;
           }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #fff;
            min-width: 220px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 10;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            top: 100%; /* Position below the button */
            left: 0;
        }
         .dropdown-content .search-container {
              margin-bottom: 8px;
           }
        .dropdown-content input[type="text"] {
            width: calc(100% - 18px);
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .dropdown-content .select-all {
            font-weight: bold;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 5px;
            cursor: pointer;
            font-size: 14px;
        }
         .dropdown-content .select-all input[type="checkbox"] {
              margin-right: 5px;
           }
        .dropdown-content .filter-options {
            margin-bottom: 5px; /* Reduced bottom margin */
        }
        .dropdown-content label {
            display: block;
            margin-bottom: 4px;
            cursor: pointer;
            font-weight: normal;
            font-size: 14px;
        }
         .dropdown-actions {
              display: none; /* Hide action buttons within dropdowns */
           }

        /* Styles for the Reorder Panel */
         #reorderPanel {
              position: fixed; /* or absolute */
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background-color: #fff;
              padding: 20px;
              border: 1px solid #ccc;
              box-shadow: 0 0 10px rgba(0,0,0,0.5);
              z-index: 100;
              max-height: 80vh;
              overflow-y: auto;
              display: none; /* Initially hidden */
           }
         #columnOrderList {
              list-style: none;
              padding: 0;
              margin: 0 0 15px 0;
           }
         #columnOrderList li {
              margin-bottom: 5px;
              padding: 8px;
              border: 1px solid #eee;
              background-color: #f9f9f9;
              display: flex;
              justify-content: space-between;
              align-items: center;
              font-size: 14px;
           }
         #columnOrderList li button {
              padding: 3px 8px;
              margin-left: 5px;
              cursor: pointer;
           }

        /* Chart-specific styles from the second code - Keeping for layout consistency */
        .chart-container { /* This container is now permanently hidden */
           display: flex;
           flex-wrap: wrap;
           gap: 20px;
           justify-content: space-between;
           width: 100%;
           height: 100%;
         }

         .chart-box { /* These boxes are now permanently hidden */
           background: white;
           border: 1px solid #ccc;
           padding: 10px;
           width: 48%;
           box-sizing: border-box;
           position: relative;
           display: flex;
           flex-direction: column;
           justify-content: stretch;
         }


         .chart-box canvas { /* These canvases are now permanently hidden */
           width: 100% !important;
           height: 100% !important;
           max-height: 100%;
         }


         .chart-toolbar { /* This toolbar is now permanently hidden */
           position: absolute;
           top: 5px;
           right: 5px;
         }
         .chart-toolbar button { /* These buttons are now permanently hidden */
           background: #1e3a8a;
           color: white;
           border: none;
           padding: 5px 8px;
           cursor: pointer;
           margin-left: 5px;
         }

    </style>
</head>
<body>

<div class="container">
    <div class="dashboard-header">
        <img src="https://www.sagarmanufacturers.com/assets/web/images/smpl-new-logo.png" alt="Company Logo"
             style="height: 60px; width: auto; margin-right: 15px;">
        <h1 class="company-name">Sagar Manufacturers Pvt. Ltd.</h1>
    </div>
    <div id="controls">
        <div id="fileInputContainer">
            <label for="excelFileInput">Choose Excel File:</label>
            <input type="file" id="excelFileInput" accept=".xls,.xlsx">
            <button onclick="goBack()"
                    style="background-color: red; color: white; padding: 8px 12px; border: none; border-radius: 4px; float: right; cursor: pointer; font-weight: bold; font-size: 16px; margin-left: auto;">
                ← Home
            </button>
        </div>

        <div id="layoutAndWidthControls" style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; flex-grow: 1;">
            <span id="layoutControlsContent" style="display: flex; align-items: center; gap: 10px; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #f9f9f9; display: none;">
                <span>Layout:</span>
                <input type="text" id="layoutNameInput" placeholder="Layout Name">
                <button id="saveLayoutButton">Save</button>
                <select id="loadLayoutSelect">
                    <option value="">- Load Layout -</option>
                </select>
                <button id="loadLayoutButton" disabled>Load</button>
                <button id="deleteLayoutButton" disabled>Delete</button>
            </span>

            <div id="applyButtonContainer">
                <button id="applyFiltersButton" style="display: none;">Apply Filters</button>
            </div>

            <div id="downloadButtons" style="display: none;">
                <span>Download:</span>
                <button id="downloadExcelButton">Excel</button>
                <button id="downloadPdfButton" class="pdf">PDF</button>
            </div>

            <div id="reorderControls" style="display: none;">
                <button id="showReorderPanelButton">Reorder Columns</button>
            </div>

            <span id="widthControlsContent" style="display: flex; align-items: center; gap: 5px; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #f9f9f9; display: none;">
                <span>Adjust Width:</span>
                <select id="columnSelectForWidth">
                    <option value="">- Select Column -</option>
                </select>
                <input type="number" id="columnWidthValue" value="150" min="10" style="width: 60px;">
                <select id="columnWidthUnit">
                    <option value="px">px</option>
                    <option value="%">%</option>
                    <option value="em">em</option>
                    <option value="cm">cm</option>
                    <option value="mm">mm</option>
                </select>
                <button id="applyColumnWidthButton">Apply</button>
            </span>

            <span id="alignmentControlsContent" style="display: flex; align-items: center; gap: 5px; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #f9f9f9; display: none;">
                <span>Align Data:</span>
                <select id="columnSelectForAlignment">
                    <option value="">- Select Column -</option>
                </select>
                <select id="columnAlignmentValue">
                    <option value="left">Left</option>
                    <option value="center">Center</option>
                    <option value="right">Right</option>
                </select>
                <button id="applyColumnAlignmentButton">Apply</button>
            </span>
        </div>

        <div id="pdfRemarksInputContainer" style="display: none; margin-top: 10px; width: 100%;">
            <label for="pdfRemarksInput">Remarks/Title for PDF:</label>
            <input type="text" id="pdfRemarksInput" placeholder="Enter remarks or title for PDF..." style="flex-grow: 1; padding: 5px;">
        </div>
    </div>

    <div id="filtersContainer" class="filter-container">
    </div>

    <div id="tableScrollContainer">
        <div id="tableContainer">
        </div>
    </div>
</div> <div id="reorderPanel" style="display: none;
    position: fixed; /* or absolute */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    padding: 20px;
    border: 1px solid #ccc;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    z-index: 100;
    max-height: 80vh;
    overflow-y: auto;">
    <h3>Reorder Columns</h3>
    <ul id="columnOrderList" style="list-style: none; padding: 0;">
    </ul>
    <button id="applyReorderButton">Apply Order</button>
    <button id="cancelReorderButton">Cancel</button>
</div>

<script>
    // Define which columns should have data filters (alphabetically sorted later)
    const dataFilterableColumnNames = [
        'Vehicle Number',
        'Bill to City',
        'Plant',
        'Customer_Name',
        'Lot No',
        'Ship to City',
        'Billing Document',
        'Delivery',
        'Sales Document',
        'SMPL Count',
        'Market',
        'Material'
    ].sort(); // Sort data filterable columns alphabetically


    let tableData = []; // Store the original data objects (keys are original headers) - This replaces your rawData
    let columnNamesFromExcel = []; // Store the exact column names read from the Excel header
    let currentAppliedDataFilters = {}; // Store the data filters currently applied to the table
    let visibleColumns = []; // Store which columns are currently visible (subset of columnNamesFromExcel)
    let currentSort = { column: null, direction: 'none' }; // State for current sorting
    let columnWidths = {}; // Store custom column widths (using cleaned column names as keys, storing strings like "500px")
    let columnDisplayOrder = []; // Store the desired order of ALL columns
    let columnAlignments = {}; // Store custom column alignments (using cleaned column names as keys, storing strings like "center")
    // Removed chart variables

    // Removed chart interaction filter variables and mapping


    // Ensure the DOM is fully loaded before adding event listeners
    document.addEventListener('DOMContentLoaded', function() {

        // Event listener for the File Input (from first code)
        document.getElementById('excelFileInput').addEventListener('change', handleFileSelect, false);

        // Event listener for the Apply Filters Button (from first code)
        document.getElementById('applyFiltersButton').addEventListener('click', applyFilters, false);

        // Event listeners for Download Buttons (from first code)
        document.getElementById('downloadExcelButton').addEventListener('click', downloadExcel, false);
        document.getElementById('downloadPdfButton').addEventListener('click', downloadPdf, false);

        // Layout Control Event Listeners (from first code)
        document.getElementById('saveLayoutButton').addEventListener('click', saveLayout, false);
        document.getElementById('loadLayoutSelect').addEventListener('change', enableLayoutButtons, false);
        document.getElementById('loadLayoutButton').addEventListener('click', loadLayout, false);
        document.getElementById('deleteLayoutButton').addEventListener('click', deleteLayout, false);

        // Column Width Adjustment Event Listener (from first code)
        document.getElementById('applyColumnWidthButton').addEventListener('click', applyColumnWidth, false);

        // Column Alignment Adjustment Event Listener (from first code)
        document.getElementById('applyColumnAlignmentButton').addEventListener('click', applyColumnAlignment, false);

        // Column Reordering Event Listeners (from first code)
        document.getElementById('showReorderPanelButton').addEventListener('click', showReorderPanel, false);
        document.getElementById('applyReorderButton').addEventListener('click', applyReorder, false);
        document.getElementById('cancelReorderButton').addEventListener('click', hideReorderPanel, false);

        // Removed View Selector event listener


        // Initial load of saved layouts on page load (from first code)
        loadSavedLayoutNames();
        enableLayoutButtons(); // Set initial button states

    }); // End DOMContentLoaded listener

    // Helper function to convert Excel date serial number (assuming 1900 system) to JavaScript Date (from first code)
    // This provides an alternative if SSF.parse_date_code is not working.
    // Based on common implementations, accounts for Excel's leap year bug in 1900.
    function excelDateToJSDate(excelDate) {
        const excelEpoch = new Date(1900, 0, 1); // Jan 1, 1900
        // Excel date system is 1-based (day 1 is 1900-01-01).
        // Excel incorrectly treats 1900 as a leap year, so Feb 29, 1900 exists in its system (day 60).
        // JavaScript Date treats 1900 correctly as not a leap year.
        // If the Excel date is after Feb 28, 1900 (serial number > 60), we need to subtract 1 day
        // to account for Excel's invalid 1900 leap day.
        const days = excelDate; // Excel serial number is the number of days since the epoch + 1

        if (days === 0) {
            return null; // Excel 0 usually means no date or blank
        }

        // Start with the Excel epoch
        let date = new Date(excelEpoch.getTime());

        // Add the number of days
        date.setDate(date.getDate() + days - 1); // -1 because Excel is 1-based

        // Adjust for Excel's incorrect leap year (if date is after 1900-02-28)
        if (days > 60) {
            date.setDate(date.getDate() - 1);
        }

        return date;
    }

    // Helper function to optimize row data (merged from second code's optimizeRow and processRow)
    function optimizeRow(row) {
        const newRow = {...row};

        // Safer Date Fix for various date fields
        ['Billing Date', 'fromdate', 'todate', 'QUERY RECEIVED DATE'].forEach(field => { // Added QUERY RECEIVED DATE
            const cleanedField = Object.keys(newRow).find(key => key.toLowerCase() === field.toLowerCase());
            if (cleanedField && newRow[cleanedField] !== undefined && newRow[cleanedField] !== null && typeof newRow[cleanedField] === 'number' && newRow[cleanedField] > 0) {
                try {
                    // Use the custom helper function for conversion
                    const date = excelDateToJSDate(newRow[cleanedField]);
                    if (date instanceof Date && !isNaN(date) && date !== null) { // Check if it's a valid and non-null Date object
                        // Format date to dd-mm-yy (or desired format)
                        const day = date.getDate().toString().padStart(2, '0');
                        const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
                        const year = date.getFullYear().toString().slice(-2); // Get last two digits of year
                        newRow[cleanedField] = `${day}-${month}-${year}`; // Store formatted date
                    } else {
                        newRow[cleanedField] = String(newRow[cleanedField]); // Fallback to original value string
                    }
                } catch (e) {
                    console.error(`Error during date conversion for field ${cleanedField}, value: ${newRow[cleanedField]}`, e);
                    newRow[cleanedField] = String(newRow[cleanedField]); // Fallback to original value string
                }
            } else if (cleanedField && newRow[cleanedField] !== undefined && newRow[cleanedField] !== null) {
                // Ensure non-numeric date-like values are also strings
                newRow[cleanedField] = String(newRow[cleanedField]);
            } else if (cleanedField) {
                // Ensure null/undefined values in target date fields are empty strings
                newRow[cleanedField] = '';
            }
        });


        // Blend Calculation Optimization (from second code)
        const smplCountKey = Object.keys(newRow).find(key => key.toLowerCase() === 'smpl count');
        const itemDescriptionKey = Object.keys(newRow).find(key => key.toLowerCase() === 'item description');
        const blendKey = Object.keys(newRow).find(key => key.toLowerCase() === 'blend');


        if (smplCountKey && itemDescriptionKey && newRow[smplCountKey]?.toString().endsWith('PC') && newRow[itemDescriptionKey]) {
            // If SMPL Count ends with 'PC' and there is an Item Description
            const match = newRow[itemDescriptionKey].match(/PC.*?(\d+)/);
            if (match) {
                const percent = parseInt(match[1], 10);  // Ensure parsing as base 10
                if (!isNaN(percent)) {
                    // Set Blend to percentage split, using the correct key if found, otherwise add 'Blend'
                    if (blendKey) {
                        newRow[blendKey] = `${percent}/${100 - percent}`;
                    } else {
                        newRow['Blend'] = `${percent}/${100 - percent}`; // Add 'Blend' if it wasn't a header
                    }
                } else {
                    // Fallback if parsing percent failed, use the correct key or add 'Blend'
                    if (blendKey) {
                        newRow[blendKey] = '';
                    } else {
                        newRow['Blend'] = ''; // Add 'Blend' if it wasn't a header
                    }
                }
            } else {
                // If Item Description doesn't match expected pattern, leave Blend empty, use the correct key or add 'Blend'
                if (blendKey) {
                    newRow[blendKey] = '';
                } else {
                    newRow['Blend'] = ''; // Add 'Blend' if it wasn't a header
                }
            }
        } else {
            // If SMPL Count does not end with 'PC', just set Blend to empty, use the correct key or add 'Blend'
            if (blendKey) {
                newRow[blendKey] = ''; // Or '100%' based on your logic, defaulted to ''
            } else {
                newRow['Blend'] = ''; // Add 'Blend' if it wasn't a header, defaulted to ''
            }
        }

        // Ensure all values are strings for consistent filtering and display
        Object.keys(newRow).forEach(key => {
            newRow[key] = newRow[key] !== undefined && newRow[key] !== null ? String(newRow[key]) : '';
        });


        return newRow;
    }



    // Function to handle the file selection and initial data loading (from first code, modified)
    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();

        reader.onload = function(e) {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });

            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];

            // Convert the worksheet data to an array of arrays, keeping raw values for date conversion
            // Use defval: '' to set undefined values to empty string
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true, defval: '' });

            // Assume the first row of jsonData is the header
            const header = jsonData[0];
            const dataRows = jsonData.slice(1);

            // Store column names directly from the header, clean them, and ensure uniqueness (from first code)
            columnNamesFromExcel = []; // Ensure re-initialization on new file load
            const seenNames = new Set();
            if (header) { // Ensure header is not null or undefined
                header.forEach(colName => {
                    const cleanedName = colName ? String(colName).trim() : `Unnamed Column_${seenNames.size}`; // Use size for unique unnamed
                    let uniqueName = cleanedName;
                    let counter = 1;
                    // Handle duplicate column names by appending a number
                    while(seenNames.has(uniqueName)) {
                        uniqueName = `${cleanedName}_${counter}`;
                        counter++;
                    }
                    columnNamesFromExcel.push(uniqueName);
                    seenNames.add(uniqueName);
                });
            } else {
                console.warn("No header row found in the Excel file.");
                // Generate some default column names if no header
                const numCols = dataRows[0] ? dataRows[0].length : 0;
                for(let i = 0; i < numCols; i++) {
                    columnNamesFromExcel.push(`Column${i+1}`);
                }
            }


            // Map data rows to objects using the cleaned header names as keys, applying optimization (from first code, modified)
            tableData = dataRows.map(row => {
                const rowObject = {};
                columnNamesFromExcel.forEach((colName, index) => { // Use cleaned header names as keys
                    rowObject[colName] = row[index]; // Store raw value first
                });
                // Apply optimization and date formatting to the row object
                return optimizeRow(rowObject); // Use the optimizeRow function here
            });


            // Initialize filters (both data filters and column visibility filter) (from first code)
            initializeFilters(tableData, columnNamesFromExcel); // Pass all column names for filters

            // Initialize applied data filters to empty, and visible columns to all excel columns (from first code)
            dataFilterableColumnNames.forEach(col => {
                // Ensure the filterable column exists in the excel file's columns (case-insensitive)
                if (columnNamesFromExcel.some(name => name.toLowerCase() === col.toLowerCase())) {
                    currentAppliedDataFilters[col] = [];
                }
            });
            visibleColumns = [...columnNamesFromExcel];
            currentSort = { column: null, direction: 'none' }; // Reset sort state on new file
            columnWidths = {}; // Reset column widths on new file unless loading layout
            columnDisplayOrder = [...columnNamesFromExcel]; // Initialize display order to match file order
            columnAlignments = {}; // Initialize column alignments to empty (defaults to left)


            // Display the initial table
            applyFilters(); // This function now handles data filtering, column visibility, and sorting
            // Removed generateCharts call


            // Show controls (from first code, modified)
            document.getElementById('applyFiltersButton').style.display = 'inline-block';
            document.getElementById('downloadButtons').style.display = 'flex';
            document.getElementById('layoutControlsContent').style.display = 'flex'; // Show layout controls content
            document.getElementById('widthControlsContent').style.display = 'flex'; // Show width controls content
            document.getElementById('alignmentControlsContent').style.display = 'flex'; // Show alignment controls content
            document.getElementById('reorderControls').style.display = 'block'; // Show reorder controls button
            document.getElementById('pdfRemarksInputContainer').style.display = 'flex'; // Show remarks input
            document.getElementById('filtersContainer').style.display = 'flex'; // Show the filters container itself


            // Load saved layouts for the new file (from first code)
            loadSavedLayoutNames(); // Call this after populating columnNamesFromExcel
            populateColumnWidthSelect(); // Populate the column select for width adjustment
            populateColumnAlignmentSelect(); // Populate the column select for alignment

        };

        reader.readAsArrayBuffer(file);
    }


    // Function to initialize filter dropdowns (data and visibility) (from first code)
    function initializeFilters(data, allColumnNames) { // Accept all column names
        const filtersContainer = document.getElementById('filtersContainer');
        filtersContainer.innerHTML = ''; // Clear previous filters

        // --- Create Column Visibility Filter --- (from first code)
        const columnVisibilityDropdownHtml = `
            <div class="filter-dropdown" data-filter-type="visibility">
                <button class="dropdown-button">Show/Hide Columns <span class="filter-arrow">&#9662;</span></button>
                <div class="dropdown-content">
                    <div class="search-container">
                        <input type="text" class="column-search" placeholder="Search...">
                    </div>
                    <label class="select-all">
                        <input type="checkbox" class="select-all-columns-checkbox" checked> Select All
                    </label>
                    <div class="column-options filter-options">
                        ${allColumnNames.map(colName => `
                            <label>
                                <input type="checkbox" class="column-checkbox" value="${colName}" checked> ${colName}
                            </label>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
        filtersContainer.innerHTML += columnVisibilityDropdownHtml;


        // --- Create Data Filters --- (from first code)
        dataFilterableColumnNames.forEach(columnName => {
            // Check if this filterable column exists in the actual Excel columns (case-insensitive match)
            if (allColumnNames.some(name => name.toLowerCase() === columnName.toLowerCase())) {
                // Get unique values from the loaded data for this specific column name
                // Need to find the exact casing from the loaded columns to get data correctly
                const exactColumnName = allColumnNames.find(name => name.toLowerCase() === columnName.toLowerCase());
                let uniqueValues = [...new Set(data.map(row => row[exactColumnName] !== undefined && row[exactColumnName] !== null ? String(row[exactColumnName]) : '').filter(value => value !== ''))];

                // --- Custom Sorting for Month Columns --- (from first code)
                if (exactColumnName && (exactColumnName.toLowerCase() === 'month' || exactColumnName.toLowerCase() === 'month')) {
                    uniqueValues.sort((a, b) => {
                        const numA = parseInt(a);
                        const numB = parseInt(b);
                        // Handle cases where conversion to number fails or is NaN
                        if (isNaN(numA) && isNaN(numB)) return 0;
                        if (isNaN(numA)) return 1; // Put non-numeric at the end
                        if (isNaN(numB)) return -1; // Put non-numeric at the end
                        return numA - numB; // Numeric sort
                    });
                } else {
                    // Default to alphabetical sort for other columns
                    uniqueValues.sort();
                }
                // --- End Custom Sorting ---


                if (uniqueValues.length > 0) {
                    const filterDropdownHtml = `
                        <div class="filter-dropdown" data-column="${columnName}" data-filter-type="data">
                            <button class="dropdown-button">${columnName} <span class="filter-arrow">&#9662;</span></button>
                            <div class="dropdown-content">
                                <div class="search-container">
                                    <input type="text" class="filter-search" placeholder="Search...">
                                </div>
                                <label class="select-all">
                                    <input type="checkbox" class="select-all-checkbox"> Select All
                                </label>
                                <div class="filter-options">
                                    ${uniqueValues.map(value => `
                                        <label>
                                            <input type="checkbox" class="filter-checkbox" value="${value}"> ${value}
                                        </label>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                    filtersContainer.innerHTML += filterDropdownHtml;
                }
            }
        });


        // Add event listeners to the newly created filter elements (from first code)
        addFilterEventListeners();
    }


    // Function to add event listeners to filter dropdowns (from first code)
    function addFilterEventListeners() {
        document.querySelectorAll('.filter-dropdown').forEach(dropdown => {
            const button = dropdown.querySelector('.dropdown-button');
            const content = dropdown.querySelector('.dropdown-content');
            const searchInput = dropdown.querySelector('.filter-search') || dropdown.querySelector('.column-search'); // Get search input for either type
            const selectAllCheckbox = dropdown.querySelector('.select-all-checkbox') || dropdown.querySelector('.select-all-columns-checkbox'); // Get select all for either type
            const optionsContainer = dropdown.querySelector('.filter-options'); // Checkboxes container

            const filterType = dropdown.getAttribute('data-filter-type');
            const columnName = dropdown.getAttribute('data-column'); // For data filters


            // Toggle dropdown visibility
            button.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent window click from closing immediately
                // Close other open dropdowns
                document.querySelectorAll('.dropdown-content').forEach(openContent => {
                    if (openContent !== content) {
                        openContent.style.display = 'none';
                    }
                });
                // Toggle current dropdown
                content.style.display = content.style.display === 'block' ? 'none' : 'block';

                // When opening, ensure checkboxes reflect current state (applied data filters or visible columns)
                if (content.style.display === 'block') {
                    let currentStateValues = [];
                    if (filterType === 'data') {
                        currentStateValues = currentAppliedDataFilters[columnName] || [];
                    } else if (filterType === 'visibility') {
                        currentStateValues = visibleColumns;
                    }

                    optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        // Find the corresponding value in currentStateValues (case-insensitive for matching)
                        // But set checked state based on exact value in the checkbox
                        checkbox.checked = currentStateValues.some(val => val.toLowerCase() === checkbox.value.toLowerCase());
                    });
                    // Update select all checkbox state on opening
                    updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                }
            });

            // Prevent clicks inside the dropdown content from closing it
            content.addEventListener('click', (event) => {
                event.stopPropagation();
            });

            // Search functionality
            if (searchInput) { // Ensure search input exists
                searchInput.addEventListener('input', () => {
                    const searchTerm = searchInput.value.toLowerCase();
                    optionsContainer.querySelectorAll('label').forEach(label => {
                        const text = label.textContent.toLowerCase();
                        label.style.display = text.includes(searchTerm) ? 'block' : 'none';
                    });
                    // After filtering search results, update the "Select All" checkbox state
                    updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                });
            }


            // Select/Unselect All functionality
            if (selectAllCheckbox) { // Ensure select all checkbox exists
                selectAllCheckbox.addEventListener('change', (event) => {
                    optionsContainer.querySelectorAll('label').forEach(label => {
                        // Only affect checkboxes of currently visible labels after search
                        if(label.style.display !== 'none') {
                            label.querySelector('input[type="checkbox"]').checked = event.target.checked;
                        }
                    });
                    // Update the state of the Select All checkbox itself (handles indeterminate)
                    updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                    // Note: Filters are applied ONLY on clicking the main Apply button now.
                });
            }


            // Individual checkbox change listener
            optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => { // Iterate over each checkbox
                checkbox.addEventListener('change', () => {
                    updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                    // Note: Filters are applied ONLY on clicking the main Apply button now.
                });
            });
        });

        // Close dropdowns when clicking outside the dropdown container (from first code)
        window.addEventListener('click', (event) => {
            document.querySelectorAll('.filter-dropdown').forEach(dropdown => {
                const content = dropdown.querySelector('.dropdown-content');
                // Use !dropdown.contains(event.target) which is simpler and safer
                if (!dropdown.contains(event.target)) {
                    content.style.display = 'none';
                    // When closing by clicking outside, reset checkboxes in open dropdowns
                    // to the currently applied filter state before closing.
                    const filterType = dropdown.getAttribute('data-filter-type');
                    const optionsContainer = dropdown.querySelector('.filter-options');
                    const selectAllCheckbox = dropdown.querySelector('.select-all-checkbox') || dropdown.querySelector('.select-all-columns-checkbox');

                    let currentStateValues = [];
                    if (filterType === 'data') {
                        const columnName = dropdown.getAttribute('data-column');
                        currentStateValues = currentAppliedDataFilters[columnName] || [];
                    } else if (filterType === 'visibility') {
                        currentStateValues = visibleColumns;
                    }

                    optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        checkbox.checked = currentStateValues.some(val => val.toLowerCase() === checkbox.value.toLowerCase()); // Case-insensitive check
                    });
                    updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                }
            });
        });
    }

    // Helper to update the state of the "Select All" checkbox (Handles indeterminate state) (from first code)
    function updateSelectAllCheckbox(optionsContainer, selectAllCheckbox) {
        if (!selectAllCheckbox) return; // Handle cases where select all might not exist

        const visibleCheckboxes = Array.from(optionsContainer.querySelectorAll('label'))
            .filter(label => label.style.display !== 'none')
            .map(label => label.querySelector('input[type="checkbox"]'));

        const checkedVisibleCheckboxes = visibleCheckboxes.filter(cb => cb.checked);

        if (visibleCheckboxes.length === 0) {
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = false;
        } else if (checkedVisibleCheckboxes.length === visibleCheckboxes.length) {
            selectAllCheckbox.checked = true;
            selectAllCheckbox.indeterminate = false;
        } else if (checkedVisibleCheckboxes.length > 0) {
            selectAllCheckbox.checked = false; // It's not 'all' if some are unchecked
            selectAllCheckbox.indeterminate = true; // But some are checked
        } else { // No visible checkboxes are checked
            selectAllCheckbox.checked = false;
            selectAllCheckbox.indeterminate = false;
        }
    }

    // Function to apply filters based on current selections in all dropdowns (from first code, completed)
    function applyFilters() {
        // --- Collect Data Filter Selections ---
        dataFilterableColumnNames.forEach(columnName => {
            // Find the dropdown for this data filterable column
            const dropdown = document.querySelector(`.filter-dropdown[data-column="${columnName}"][data-filter-type="data"]`);
            if (dropdown) {
                const selectedValues = [];
                dropdown.querySelectorAll('.filter-options .filter-checkbox:checked').forEach(checkbox => {
                    selectedValues.push(checkbox.value);
                });
                currentAppliedDataFilters[columnName] = selectedValues; // Update the globally applied data filters
            } else {
                // If a filterable column does not have a dropdown (e.g., no unique values),
                // ensure its filter is also reset or empty in the applied state
                currentAppliedDataFilters[columnName] = [];
            }
        });

        // --- Collect Column Visibility Selections ---
        const selectedVisibleColumns = [];
        const visibilityDropdown = document.querySelector('.filter-dropdown[data-filter-type="visibility"]');
        if (visibilityDropdown) {
            visibilityDropdown.querySelectorAll('.column-options .column-checkbox:checked').forEach(checkbox => {
                selectedVisibleColumns.push(checkbox.value);
            });
        }
        visibleColumns = selectedVisibleColumns; // Update the globally visible columns

        // --- Apply Data Filters ---
        let filteredData = tableData; // Start with all loaded data

        dataFilterableColumnNames.forEach(columnName => {
            const selectedValues = currentAppliedDataFilters[columnName]; // Use currently applied data filters
            if (selectedValues && selectedValues.length > 0) {
                filteredData = filteredData.filter(row => {
                    // Find the actual key in the row object based on the filter column name (case-insensitive)
                    const rowKey = Object.keys(row).find(key => key.toLowerCase() === columnName.toLowerCase());
                    if (rowKey) {
                        const rowValue = row[rowKey] !== undefined && row[rowKey] !== null ? String(row[rowKey]) : '';
                        return selectedValues.includes(rowValue);
                    }
                    return false; // If the filter column doesn't exist in the row, filter it out
                });
            }
        });

        // --- Apply Sorting ---
        // Sorting logic remains, but the click handler prevents sorting during resize (though resizing is removed now)
        if (currentSort.column) {
            const sortColumnName = currentSort.column;
            const sortDirection = currentSort.direction;

            // Find the actual column name in the data based on the sortColumnName (case-insensitive)
            const actualSortColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === sortColumnName.toLowerCase());

            if (actualSortColumnName) {
                filteredData.sort((a, b) => {
                    const aValue = a[actualSortColumnName] !== undefined && a[actualSortColumnName] !== null ? String(a[actualSortColumnName]) : '';
                    const bValue = b[actualSortColumnName] !== undefined && b[actualSortColumnName] !== null ? String(b[actualSortColumnName]) : '';

                    // Special handling for month columns for sorting
                    if (actualSortColumnName.toLowerCase() === 'month' || actualSortColumnName.toLowerCase() === 'month') {
                        const numA = parseInt(aValue);
                        const numB = parseInt(bValue);
                        if (isNaN(numA) && isNaN(numB)) return 0;
                        if (isNaN(numA)) return 1;
                        if (isNaN(numB)) return -1;
                        return sortDirection === 'asc' ? numA - numB : numB - numA; // Use numB - numA for desc
                    }


                    // Basic string comparison for sorting for other columns
                    if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
                    if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
                    return 0; // Values are equal
                });
            }
        }

        // --- Display the table with filtered data and selected columns ---
        displayTable(filteredData, visibleColumns);

        // Update the column select dropdowns for width and alignment after displaying
        populateColumnWidthSelect();
        populateColumnAlignmentSelect();
    }


    // Function to display the table using manual HTML (replaces Grid.js render) (from first code)
    function displayTable(data, columnsToDisplay) {
        const tableContainer = document.getElementById('tableContainer');
        tableContainer.innerHTML = ''; // Clear previous table

        // Check if there is data to display and columns selected
        // Note: We iterate based on columnDisplayOrder, but check if it's in visibleColumns
        const columnsToRender = columnDisplayOrder.filter(col =>
            visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())
        );


        if (data.length > 0 && columnsToRender.length > 0) {
            let html = '<table>';

            // Add colgroup for fixed column widths
            html += '<colgroup>';
            // Iterate through the display order, but only add cols for visible columns
            columnDisplayOrder.forEach(col => {
                // Check if this column is in the currently visible columns list (case-insensitive)
                if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                    // Find the corresponding actual column name from Excel header (case-insensitive) to get width
                    const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                    if (actualColumnName) {
                        let colWidth = columnWidths[actualColumnName]; // Get saved width first

                        // If no saved width, apply default width
                        if (!colWidth) {
                            // Apply default widths based on the actual column name
                            if (actualColumnName === 'ANALYSIS AND OUTCOME' || actualColumnName === 'ACTION TAKEN') {
                                colWidth = '700px'; // Increased Default Wider Width
                            } else if (actualColumnName.toLowerCase() === 'query received date') {
                                colWidth = '120px'; // Default for date
                            } else if (actualColumnName.toLowerCase() === 'unit no' || actualColumnName.toLowerCase() === 'status' || actualColumnName.toLowerCase() === 'cotton' || actualColumnName.toLowerCase() === 'count' || actualColumnName.toLowerCase() === 'mfg year' || actualColumnName.toLowerCase() === 'year' || actualColumnName.toLowerCase() === 'month' || actualColumnName.toLowerCase() === 'month') { // Added month columns here
                                colWidth = '80px'; // Default for smaller columns
                            } else {
                                colWidth = '150px'; // General default width
                            }
                            // Store the determined default width as a string (optional, but keeps columnWidths updated)
                            // columnWidths[actualColumnName] = colWidth; // Be careful if loading layouts overwrites
                        }

                        // Use the column name from columnDisplayOrder for the col element's data attribute
                        html += `<col data-column-name="${col}" style="width: ${colWidth};">`;
                    }
                }
            });
            html += '</colgroup>';


            html += '<thead><tr>';
            // Add headers for the selected columns based on the display order
            columnDisplayOrder.forEach(col => {
                // Only add header if the column is currently visible (case-insensitive)
                if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                    // Find the corresponding actual column name from Excel header (case-insensitive) to use for data attribute
                    const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                    if (actualColumnName) {
                        let sortArrow = '';
                        if (currentSort.column && currentSort.column.toLowerCase() === col.toLowerCase()) { // Match sort state using the column from displayOrder
                            sortArrow = currentSort.direction === 'asc' ? ' &#9650;' : ' &#9660;'; // Up/Down arrow
                        }
                        // Apply header alignment from columnAlignments
                        const headerAlignment = actualColumnName ? columnAlignments[actualColumnName] : 'left'; // Default header alignment to left
                        html += `<th data-column-name="${col}" style="text-align: ${headerAlignment};">${col}<span class="sort-arrow">${sortArrow}</span></th>`; // Use column from displayOrder for header text and data attribute
                    }
                }
            });
            html += '</tr></thead><tbody>';

            // Add rows for the filtered data, showing only selected columns in the specified display order
            data.forEach(row => {
                html += '<tr>';
                // Iterate through the display order
                columnDisplayOrder.forEach(col => {
                    // Only add td if the column is currently visible (case-insensitive)
                    if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                        // Find the actual key in the row object based on the column name from display order (case-insensitive)
                        const rowKey = Object.keys(row).find(key => key.toLowerCase() === col.toLowerCase());
                        const cellValue = rowKey ? row[rowKey] : ''; // Use empty string if column data is missing
                        // Apply cell alignment from columnAlignments
                        const actualColName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase()); // Find actual name for alignment lookup
                        const cellAlignment = actualColName ? columnAlignments[actualColName] : 'left'; // Default cell alignment to left

                        html += `<td style="text-align: ${cellAlignment};">${cellValue}</td>`;
                    }
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            tableContainer.innerHTML = html;

            // Add sorting event listeners to the new headers
            addSortEventListeners();


        } else if (columnsToRender.length === 0) {
            tableContainer.innerHTML = '<p>No columns selected to display.</p>';
        } else {
            tableContainer.innerHTML = '<p>No data matches the current filter criteria.</p>';
        }
        // Update the column select dropdowns for width and alignment after displaying
        populateColumnWidthSelect();
        populateColumnAlignmentSelect();
    }

    // --- Sorting Functionality ---
    function addSortEventListeners() {
        document.querySelectorAll('#tableContainer th').forEach(header => {
            // Remove existing listeners to prevent duplicates
            // Using removeEventListener with the same function reference works.
            // We need a way to store the *specific* handler function for this header.
            // The data-sort-handler approach using window object is one way,
            // another is to store the function reference directly on the header element's dataset.

            // Remove previous listener if it exists
            if (header.dataset.sortHandlerRef) {
                header.removeEventListener('click', header.dataset.sortHandlerRef);
                delete header.dataset.sortHandlerRef;
            }

            const clickHandler = () => {
                const columnName = header.getAttribute('data-column-name'); // Use column name from display order
                let newDirection = 'asc';

                if (currentSort.column === columnName) {
                    if (currentSort.direction === 'asc') {
                        newDirection = 'desc';
                    } else if (currentSort.direction === 'desc') {
                        newDirection = 'none'; // Cycle to no sort
                    } else {
                        newDirection = 'asc'; // From none to asc
                    }
                }

                if (newDirection === 'none') {
                    currentSort = { column: null, direction: 'none' };
                } else {
                    currentSort = { column: columnName, direction: newDirection };
                }

                applyFilters(); // Re-apply filters, which now includes sorting
            };

            // Store the handler function reference on the element's dataset
            header.dataset.sortHandlerRef = clickHandler;
            header.addEventListener('click', clickHandler);
        });
    }

    // --- Column Reordering Functionality --- (from first code)

    function showReorderPanel() {
        if (columnNamesFromExcel.length === 0) {
            alert("Please load an Excel file first to reorder columns.");
            return;
        }
        const list = document.getElementById('columnOrderList');
        list.innerHTML = ''; // Clear current list

        // Populate the list with current display order
        columnDisplayOrder.forEach(colName => {
            const listItem = document.createElement('li');
            listItem.setAttribute('data-column-name', colName);
            listItem.style.marginBottom = '5px';
            listItem.style.padding = '8px';
            listItem.style.border = '1px solid #eee';
            listItem.style.backgroundColor = '#f9f9f9';
            listItem.style.display = 'flex';
            listItem.style.justifyContent = 'space-between';
            listItem.style.alignItems = 'center';
            listItem.style.cursor = 'grab'; // Indicate draggable (optional, if implementing drag/drop later)

            const colNameSpan = document.createElement('span');
            colNameSpan.textContent = colName;
            listItem.appendChild(colNameSpan);

            const buttonsDiv = document.createElement('div');
            const upButton = document.createElement('button');
            upButton.textContent = '▲';
            upButton.style.marginLeft = '10px';
            upButton.style.cursor = 'pointer';
            upButton.onclick = () => moveColumnInList(colName, 'up');
            buttonsDiv.appendChild(upButton);

            const downButton = document.createElement('button');
            downButton.textContent = '▼';
            downButton.style.marginLeft = '5px';
            downButton.style.cursor = 'pointer';
            downButton.onclick = () => moveColumnInList(colName, 'down');
            buttonsDiv.appendChild(downButton);

            listItem.appendChild(buttonsDiv);
            list.appendChild(listItem);
        });

        document.getElementById('reorderPanel').style.display = 'block';
    }

    function hideReorderPanel() {
        document.getElementById('reorderPanel').style.display = 'none';
        // Optional: If you want to reset order on cancel, save a temp copy in showReorderPanel
        // For simplicity now, cancel just closes without resetting
    }

    function goBack() {
        window.location.href = "protected.html";
    }

    function moveColumnInList(columnName, direction) {
        const oldIndex = columnDisplayOrder.indexOf(columnName);
        if (oldIndex === -1) return;

        let newIndex = oldIndex;
        if (direction === 'up' && oldIndex > 0) {
            newIndex = oldIndex - 1;
        } else if (direction === 'down' && oldIndex < columnDisplayOrder.length - 1) {
            newIndex = oldIndex + 1;
        } else {
            return; // Cannot move further
        }

        // Swap elements in the array
        const temp = columnDisplayOrder[oldIndex];
        columnDisplayOrder[oldIndex] = columnDisplayOrder[newIndex];
        columnDisplayOrder[newIndex] = temp;

        // Update the list display without recreating all elements (more efficient)
        const list = document.getElementById('columnOrderList');
        const items = Array.from(list.children); // Get current list items

        const movedItem = items[oldIndex];
        const targetItem = items[newIndex];

        if (direction === 'up') {
            list.insertBefore(movedItem, targetItem); // Insert moved before target
        } else { // direction === 'down'
            list.insertBefore(movedItem, targetItem.nextSibling); // Insert moved after target
        }
        // Re-attach event listeners if needed, but onclick is simple enough here
    }


    function applyReorder() {
        // columnDisplayOrder array is already updated by moveColumnInList
        hideReorderPanel();
        applyFilters(); // Re-render the table with the new order
    }


    // --- Column Width Adjustment Controls --- (from first code)

    // Function to populate the column select dropdown for width adjustment
    function populateColumnWidthSelect() {
        const selectElement = document.getElementById('columnSelectForWidth');
        selectElement.innerHTML = '<option value="">- Select Column -</option>'; // Clear and add default

        // Use the list of columns from the uploaded file
        columnNamesFromExcel.forEach(colName => {
            const option = document.createElement('option');
            option.value = colName;
            option.textContent = colName;
            selectElement.appendChild(option);
        });

        // Reset width input and unit
        document.getElementById('columnWidthValue').value = 150; // Default value
        document.getElementById('columnWidthUnit').value = 'px'; // Default unit
    }

    // Function to apply the manually entered column width
    function applyColumnWidth() {
        const selectElement = document.getElementById('columnSelectForWidth');
        const columnName = selectElement.value;
        const widthValueInput = document.getElementById('columnWidthValue');
        const widthValue = parseFloat(widthValueInput.value);
        const widthUnit = document.getElementById('columnWidthUnit').value;

        if (!columnName) {
            alert("Please select a column first.");
            return;
        }
        if (isNaN(widthValue) || widthValue <= 0) {
            alert("Please enter a valid positive number for the width.");
            widthValueInput.focus();
            return;
        }
        // Find the actual column name from Excel header (case-insensitive) to use as key
        const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === columnName.toLowerCase());

        if (actualColumnName) {
            const widthString = `${widthValue}${widthUnit}`;
            columnWidths[actualColumnName] = widthString; // Store the width string

            // Re-apply filters to redraw the table with the new width
            applyFilters();
            alert(`Width of column "${actualColumnName}" set to ${widthString}.`);
        } else {
            alert(`Error: Could not find column "${columnName}" from Excel headers.`);
        }
    }

    // --- Column Alignment Adjustment Controls --- (from first code)

    // Function to populate the column select dropdown for alignment adjustment
    function populateColumnAlignmentSelect() {
        const selectElement = document.getElementById('columnSelectForAlignment');
        selectElement.innerHTML = '<option value="">- Select Column -</option>'; // Clear and add default

        // Use the list of columns from the uploaded file
        columnNamesFromExcel.forEach(colName => {
            const option = document.createElement('option');
            option.value = colName;
            option.textContent = colName;
            selectElement.appendChild(option);
        });

        // Reset alignment select
        document.getElementById('columnAlignmentValue').value = 'left'; // Default alignment
    }

    // Function to apply the manually selected column alignment
    function applyColumnAlignment() {
        const selectElement = document.getElementById('columnSelectForAlignment');
        const columnName = selectElement.value;
        const alignmentValue = document.getElementById('columnAlignmentValue').value;

        if (!columnName) {
            alert("Please select a column first.");
            return;
        }

        // Find the actual column name from Excel header (case-insensitive) to use as key
        const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === columnName.toLowerCase());

        if (actualColumnName) {
            columnAlignments[actualColumnName] = alignmentValue; // Store the alignment string
            applyFilters(); // Re-render the table with the new alignment
            alert(`Alignment of column "${actualColumnName}" set to "${alignmentValue}".`);
        } else {
            alert(`Error: Could not find column "${columnName}" from Excel headers.`);
        }
    }

    // --- Layout Saving/Loading --- (from first code)
    const LAYOUT_STORAGE_KEY = 'excelTableLayouts';


    function getSavedLayouts() {
        const layouts = localStorage.getItem(LAYOUT_STORAGE_KEY);
        return layouts ? JSON.parse(layouts) : {};
    }

    function saveLayout() {
        const layoutNameInput = document.getElementById('layoutNameInput');
        const layoutName = layoutNameInput.value.trim();
        if (!layoutName) {
            alert("Please enter a name for the layout.");
            return;
        }

        const savedLayouts = getSavedLayouts();

        // Store columnWidths, columnDisplayOrder, and columnAlignments as part of the layout state
        const currentLayoutState = {
            dataFilters: currentAppliedDataFilters,
            visibleColumns: visibleColumns,
            columnWidths: {...columnWidths }, // Save a copy of current widths
            columnDisplayOrder: [...columnDisplayOrder], // Save a copy of the current display order
            columnAlignments: {...columnAlignments } // Save a copy of current alignments
        };

        savedLayouts[layoutName] = currentLayoutState;
        localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(savedLayouts));

        alert(`Layout "${layoutName}" saved.`);
        layoutNameInput.value = ''; // Clear input
        loadSavedLayoutNames(); // Refresh dropdown
        enableLayoutButtons(); // Update button states
    }

    function loadLayout() {
        const selectElement = document.getElementById('loadLayoutSelect');
        const layoutName = selectElement.value;

        if (!layoutName) {
            alert("Please select a layout to load.");
            return;
        }

        const savedLayouts = getSavedLayouts();
        const layoutToLoad = savedLayouts[layoutName];

        if (layoutToLoad) {
            // Check if a file is loaded
            if (tableData.length === 0) { // Use tableData which holds the raw data
                alert("Please upload an Excel file first before loading a layout.");
                selectElement.value = ""; // Reset select
                enableLayoutButtons();
                return;
            }

            // Check if the columns in the saved layout roughly match the columns of the currently loaded file
            // This is a basic check; perfect matching might be complex with cleaned names
            const savedColumnNames = new Set();
            if (layoutToLoad.dataFilters) {
                Object.keys(layoutToLoad.dataFilters).forEach(col => savedColumnNames.add(col.toLowerCase()));
            }
            if (layoutToLoad.visibleColumns) {
                layoutToLoad.visibleColumns.forEach(col => savedColumnNames.add(col.toLowerCase()));
            }
            if (layoutToLoad.columnWidths) {
                Object.keys(layoutToLoad.columnWidths).forEach(col => savedColumnNames.add(col.toLowerCase()));
            }
            if (layoutToLoad.columnDisplayOrder) {
                layoutToLoad.columnDisplayOrder.forEach(col => savedColumnNames.add(col.toLowerCase()));
            }
            if (layoutToLoad.columnAlignments) { // Check for alignments
                Object.keys(layoutToLoad.columnAlignments).forEach(col => savedColumnNames.add(col.toLowerCase()));
            }


            const currentFileColumnNamesLower = new Set(columnNamesFromExcel.map(name => name.toLowerCase()));

            const allSavedColumnsExist = Array.from(savedColumnNames).every(col => currentFileColumnNamesLower.has(col));


            if (!allSavedColumnsExist) {
                alert(`Warning: The columns referenced in the saved layout "${layoutName}" do not fully match the columns in the current Excel file. Loading may result in unexpected filtering, column visibility, or widths/alignments for mismatched columns.`);
            }


            // Apply the loaded filters, visible columns, column widths, alignment, and display order
            currentAppliedDataFilters = layoutToLoad.dataFilters || {}; // Use empty object if undefined
            visibleColumns = layoutToLoad.visibleColumns || [...columnNamesFromExcel]; // Default to all if undefined
            columnWidths = layoutToLoad.columnWidths || {}; // Use empty object if undefined
            columnDisplayOrder = layoutToLoad.columnDisplayOrder || [...columnNamesFromExcel]; // Default to file order if undefined
            columnAlignments = layoutToLoad.columnAlignments || {}; // Use empty object if undefined


            // Ensure visibleColumns only contains columns present in the current file
            visibleColumns = visibleColumns.filter(col => columnNamesFromExcel.some(name => name.toLowerCase() === col.toLowerCase()));
            // If visibleColumns becomes empty after filtering, default to showing all if file has columns
            if (visibleColumns.length === 0 && columnNamesFromExcel.length > 0) {
                visibleColumns = [...columnNamesFromExcel];
            }

            // Ensure columnDisplayOrder only contains columns present in the current file and add new ones
            const currentFileColumnNamesExact = new Set(columnNamesFromExcel);
            // Filter out saved columns that don't exist in the current file
            columnDisplayOrder = columnDisplayOrder.filter(col => currentFileColumnNamesExact.has(col));
            // Add any columns from the current file that were NOT in the saved layout's display order to the end
            currentFileColumnNamesExact.forEach(col => {
                if (!columnDisplayOrder.includes(col)) {
                    columnDisplayOrder.push(col);
                }
            });
            // If columnDisplayOrder becomes empty (shouldn't happen if file has columns), default to file order
            if (columnDisplayOrder.length === 0 && columnNamesFromExcel.length > 0) {
                columnDisplayOrder = [...columnNamesFromExcel];
            }

            // Ensure columnAlignments only contains entries for columns present in the current file
            const loadedAlignments = layoutToLoad.columnAlignments || {};
            columnAlignments = {}; // Start fresh
            columnNamesFromExcel.forEach(col => {
                // Find the key in the loaded alignments based on current file name (case-insensitive)
                const loadedKey = Object.keys(loadedAlignments).find(key => key.toLowerCase() === col.toLowerCase());
                if (loadedKey && ['left', 'center', 'right'].includes(loadedAlignments[loadedKey])) {
                    columnAlignments[col] = loadedAlignments[loadedKey]; // Use exact current column name as key
                }
            });


            // Update the visual state of the filter dropdowns to match the loaded layout
            updateFilterDropdownsVisuals();

            // Apply the filters and update the table
            applyFilters();

            alert(`Layout "${layoutName}" loaded.`);
        } else {
            alert(`Layout "${layoutName}" not found.`);
        }
    }

    function deleteLayout() {
        const selectElement = document.getElementById('loadLayoutSelect');
        const layoutName = selectElement.value;

        if (!layoutName) {
            alert("Please select a layout to delete.");
            return;
        }

        if (confirm(`Are you sure you want to delete the layout "${layoutName}"?`)) {
            const savedLayouts = getSavedLayouts();
            delete savedLayouts[layoutName];
            localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(savedLayouts));
            alert(`Layout "${layoutName}" deleted.`);
            loadSavedLayoutNames(); // Refresh dropdown
            enableLayoutButtons(); // Update button states
        }
    }

    function loadSavedLayoutNames() {
        const selectElement = document.getElementById('loadLayoutSelect');
        selectElement.innerHTML = '<option value="">- Load Layout -</option>'; // Clear and add default

        const savedLayouts = getSavedLayouts();
        for (const name in savedLayouts) {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            selectElement.appendChild(option);
        }
        enableLayoutButtons(); // Update button states
    }

    function enableLayoutButtons() {
        const selectElement = document.getElementById('loadLayoutSelect');
        const loadButton = document.getElementById('loadLayoutButton');
        const deleteButton = document.getElementById('deleteLayoutButton');
        const layoutNameInput = document.getElementById('layoutNameInput');
        const saveButton = document.getElementById('saveLayoutButton');


        const isLayoutSelected = selectElement.value !== "";
        loadButton.disabled = !isLayoutSelected;
        deleteButton.disabled = !isLayoutSelected;

        // Enable save button only if a name is entered AND a file is loaded
        saveButton.disabled = layoutNameInput.value.trim() === "" || tableData.length === 0; // Use tableData for file loaded check
        // Update save button state when input changes
        layoutNameInput.removeEventListener('input', handleLayoutNameInput); // Prevent adding multiple listeners
        layoutNameInput.addEventListener('input', handleLayoutNameInput);

    }

    function handleLayoutNameInput() {
        const layoutNameInput = document.getElementById('layoutNameInput');
        const saveButton = document.getElementById('saveLayoutButton');
        saveButton.disabled = layoutNameInput.value.trim() === "" || tableData.length === 0; // Use tableData for file loaded check
    }

    // Function to update the visual state of filter dropdowns to match currentAppliedDataFilters and visibleColumns (from first code)
    function updateFilterDropdownsVisuals() {
        // Update Data Filter dropdowns
        document.querySelectorAll('.filter-dropdown[data-filter-type="data"]').forEach(dropdown => {
            const columnName = dropdown.getAttribute('data-column');
            const selectedValues = currentAppliedDataFilters[columnName] || [];
            const optionsContainer = dropdown.querySelector('.filter-options');
            const selectAllCheckbox = dropdown.querySelector('.select-all-checkbox');

            optionsContainer.querySelectorAll('.filter-checkbox').forEach(checkbox => {
                checkbox.checked = selectedValues.some(val => val.toLowerCase() === checkbox.value.toLowerCase()); // Case-insensitive check
            });
            updateSelectAllCheckbox(optionsContainer, selectAllCheckbox); // Update select all state
        });

        // Update Column Visibility dropdown
        const visibilityDropdown = document.querySelector('.filter-dropdown[data-filter-type="visibility"]');
        if (visibilityDropdown) {
            const optionsContainer = visibilityDropdown.querySelector('.filter-options');
            const selectAllCheckbox = visibilityDropdown.querySelector('.select-all-columns-checkbox');

            optionsContainer.querySelectorAll('.column-checkbox').forEach(checkbox => {
                checkbox.checked = visibleColumns.some(val => val.toLowerCase() === checkbox.value.toLowerCase()); // Case-insensitive check
            });
            updateSelectAllCheckbox(optionsContainer, selectAllCheckbox); // Update select all state
        }
        // Note: Column width input/select are updated in populateColumnWidthSelect
        // Alignment select is updated in populateColumnAlignmentSelect
    }

    // Removed chart generation, interaction, and download functions


    // --- Download Functionality --- (from first code, completed)

    function downloadExcel() {
        // Get the data currently displayed in the table (filtered data)
        let filteredData = tableData; // Start with all data

        // Apply data filters first (Logic from applyFilters)
        dataFilterableColumnNames.forEach(columnName => {
            const selectedValues = currentAppliedDataFilters[columnName]; // Use currently applied data filters
            if (selectedValues && selectedValues.length > 0) {
                filteredData = filteredData.filter(row => {
                    // Find the actual key in the row object based on the filter column name (case-insensitive)
                    const rowKey = Object.keys(row).find(key => key.toLowerCase() === columnName.toLowerCase());
                    if (rowKey) {
                        const rowValue = row[rowKey] !== undefined && row[rowKey] !== null ? String(row[rowKey]) : '';
                        return selectedValues.includes(rowValue);
                    }
                    return false;
                });
            }
        });

        // Apply sorting (Logic from applyFilters)
        if (currentSort.column) {
            const sortColumnName = currentSort.column;
            const sortDirection = currentSort.direction;
            const actualSortColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === sortColumnName.toLowerCase());
            if (actualSortColumnName) {
                filteredData.sort((a, b) => {
                    const aValue = a[actualSortColumnName] !== undefined && a[actualSortColumnName] !== null ? String(a[actualSortColumnName]) : '';
                    const bValue = b[actualSortColumnName] !== undefined && b[actualSortColumnName] !== null ? String(b[actualSortColumnName]) : '';
                    // Special handling for month columns for sorting
                    if (actualSortColumnName.toLowerCase() === 'month' || actualSortColumnName.toLowerCase() === 'month') {
                        const numA = parseInt(aValue);
                        const numB = parseInt(bValue);
                        if (isNaN(numA) && isNaN(numB)) return 0;
                        if (isNaN(numA)) return 1;
                        if (isNaN(numB)) return -1;
                        return sortDirection === 'asc' ? numA - numB : numB - numA; // Use numB - numA for desc
                    }
                    if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
                    if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
                    return 0;
                });
            }
        }


        // Now extract data only for visible columns based on the current display order
        const dataToDownload = [];

        // Add headers for visible columns, using actual column names for better representation in Excel, respecting display order
        const headersToDownload = [];
        columnDisplayOrder.forEach(col => {
            if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                // Find the corresponding actual column name from Excel header (case-insensitive)
                const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                headersToDownload.push(actualColumnName || col); // Use actual if found, fallback to processed
            }
        });
        dataToDownload.push(headersToDownload);

        // Add row data for visible columns, respecting display order
        filteredData.forEach(row => {
            const rowArray = [];
            columnDisplayOrder.forEach(col => {
                if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                    // Find the actual key in the row object based on the column name from display order (case-insensitive)
                    const rowKey = Object.keys(row).find(key => key.toLowerCase() === col.toLowerCase());
                    rowArray.push(rowKey ? row[rowKey] : ''); // Use row[rowKey] directly
                }
            });
            dataToDownload.push(rowArray);
        });


        if (dataToDownload.length <= 1) { // Only header row or no data
            alert("No data to download based on current filters and column selections.");
            return;
        }

        // Create a new workbook and worksheet
        const ws = XLSX.utils.aoa_to_sheet(dataToDownload);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "FilteredTable"); // Sheet name
        wb.Props = {
            Title: "Filtered Table Data",
            Subject: "Table Data Download",
            Author: "Web Page Script",
            CreatedDate: new Date()
        };


        // Write and download the file
        XLSX.writeFile(wb, "table_data.xlsx");
    }
 

    // Function to download PDF (from first code, completed and slightly modified)
    function downloadPdf() {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('l', 'pt', 'a4'); // Landscape A4

        // Data for autoTable - get filtered and sorted data (reuse logic from applyFilters)
        let filteredData = tableData; // Start with all data
        // Apply data filters (Logic from applyFilters)
        dataFilterableColumnNames.forEach(columnName => {
            const selectedValues = currentAppliedDataFilters[columnName];
            if (selectedValues && selectedValues.length > 0) {
                filteredData = filteredData.filter(row => {
                    const rowKey = Object.keys(row).find(key => key.toLowerCase() === columnName.toLowerCase());
                    if (rowKey) {
                        const rowValue = row[rowKey] !== undefined && row[rowKey] !== null ? String(row[rowKey]) : '';
                        return selectedValues.includes(rowValue);
                    }
                    return false;
                });
            }
        });
        // Apply sorting (Logic from applyFilters)
        if (currentSort.column) {
            const sortColumnName = currentSort.column;
            const sortDirection = currentSort.direction;
            const actualSortColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === sortColumnName.toLowerCase());
            if (actualSortColumnName) {
                filteredData.sort((a, b) => {
                    const aValue = a[actualSortColumnName] !== undefined && a[actualSortColumnName] !== null ? String(a[actualSortColumnName]) : '';
                    const bValue = b[actualSortColumnName] !== undefined && b[actualSortColumnName] !== null ? String(b[actualSortColumnName]) : '';
                    // Special handling for month columns for sorting
                    if (actualSortColumnName.toLowerCase() === 'month' || actualSortColumnName.toLowerCase() === 'month') {
                        const numA = parseInt(aValue);
                        const numB = parseInt(bValue);
                        if (isNaN(numA) && isNaN(numB)) return 0;
                        if (isNaN(numA)) return 1;
                        if (isNaN(numB)) return -1;
                        return sortDirection === 'asc' ? numA - numB : numB - numA;
                    }
                    if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
                    if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
                    return 0;
                });
            }
        }


        // Prepare table headers and rows based on visible columns and display order
        const pdfHeaders = [];
        const pdfRows = [];
        const columnStyles = {}; // To store alignment and potential width hints for autoTable

        // Headers - iterate columnDisplayOrder, check visibility
        let colIndex = 0;
        columnDisplayOrder.forEach(col => {
            if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                pdfHeaders.push(col); // Use the column name from display order for the header

                // Apply header and cell alignment from columnAlignments
                const actualColName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                const alignment = actualColName ? columnAlignments[actualColName] : 'left'; // Default alignment to left
                columnStyles[colIndex] = { halign: alignment, valign: 'top' }; // Apply to autoTable headStyles and bodyStyles

                // Try to apply column widths to autoTable
                if (actualColName && columnWidths[actualColName]) {
                    const widthStr = columnWidths[actualColName];
                    if (widthStr.endsWith('px')) {
                        // Convert px to points (assuming 1px = 0.75pt)
                        const widthInPoints = parseFloat(widthStr) * 0.75;
                        columnStyles[colIndex].cellWidth = widthInPoints;
                    }
                    // autoTable handles % widths relatively well on its own
                    // For other units, you might need a more complex conversion or let autoTable handle it
                }

                colIndex++; // Increment index only for visible columns
            }
        });

        // Rows - iterate filteredData, then columnDisplayOrder, check visibility
        filteredData.forEach(rowData => {
            const rowArray = [];
            columnDisplayOrder.forEach(col => {
                if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                    // Find the actual key in the row object based on the column name from display order (case-insensitive)
                    const rowKey = Object.keys(rowData).find(key => key.toLowerCase() === col.toLowerCase());
                    rowArray.push(rowKey ? rowData[rowKey] : ''); // Use rowData[rowKey] directly
                }
            });
            pdfRows.push(rowArray);
        });

        if (pdfHeaders.length === 0 || pdfRows.length === 0) {
            alert("No data or visible columns to download as PDF.");
            return;
        }

        // Get remarks for PDF (which will act as the title)
        const remarks = document.getElementById('pdfRemarksInput').value.trim();

        // Calculate required height for the header area (Company Name + Remarks + padding)
        const margin = 40;
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const companyNameHeightEst = 16 * 1.2; // Estimate height of Company Name text (font size * line spacing factor)
        const remarksLineHeightEst = 14 * 1.2; // Estimate height of one line of remarks text
        let remarksBlockHeight = 0;
        if (remarks) {
            const splitRemarks = pdf.splitTextToSize(remarks, pdfWidth - 2 * margin);
            remarksBlockHeight = splitRemarks.length * remarksLineHeightEst;
        }
        // Add padding: 15 after Company Name, 20 after Remarks before table
        const paddingAfterCompanyName = 15;
        const paddingAfterRemarks = 20;

        let headerHeightPt = margin + companyNameHeightEst + paddingAfterCompanyName + remarksBlockHeight + paddingAfterRemarks;

        // Ensure minimum space if no remarks
        if (!remarks) {
            headerHeightPt = margin + companyNameHeightEst + paddingAfterCompanyName + paddingAfterRemarks;
        }

        // Add some extra safety padding if needed, or adjust the padding values above
        headerHeightPt += 10; // Add a little extra safety margin


        // *** Add this specific headStyle override for the first column ***
        // No need for this specific override if columnStyles halign is applied correctly to headStyles
        // as part of the columnStyles object definition. The halign in columnStyles
        // should apply to both head and body for that column index. Let's rely on the
        // halign set in the loop above within columnStyles.
        // *************************************************************


        pdf.autoTable({
            head: [pdfHeaders],
            body: pdfRows,
            // Set startY to the calculated header height to ensure the table starts below it on the first page
            startY: headerHeightPt,
            theme: 'grid',
            headStyles: {
                fillColor: '#e0f7fa', // Light blue header background
                textColor: '#333',
                fontStyle: 'bold',
                // halign is now applied per column from columnStyles
                valign: 'top'
            },
            bodyStyles: {
                textColor: '#333',
                valign: 'top'
                // halign is applied per column in columnStyles
            },
            alternateRowStyles: {
                fillColor: '#f5f5f5' // Light gray for alternate rows (optional, but nice)
            },
            columnStyles: columnStyles, // Apply stored column styles (width and alignment)
            tableWidth: 'auto', // Make table fill page width
            margin: { top: headerHeightPt, bottom: 40, left: 40, right: 40 }, // Set margin.top to the calculated header height
            // didDrawPage will now draw header content within the top margin area
            didDrawPage: function(data) {
                const pageMargin = 40; // Use the same margin value as used for table margin
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();

                // Company Name (Draw within the top margin)
                pdf.setFontSize(16);
                pdf.setTextColor('#000080');
                const companyNameY = pageMargin + 15; // Position below top page margin + some padding
                pdf.text('Sagar Manufacturers Pvt. Ltd.', pageMargin, companyNameY);

                // Add remarks (acting as title) if present, below the company name
                if (remarks) {
                    const companyNameBottom = companyNameY + (16 * 1.2); // Estimate bottom of company name text
                    const remarksYPos = companyNameBottom + 10; // Position below company name + padding
                    pdf.setFontSize(14); // Use title font size for remarks
                    pdf.setTextColor('#333'); // Use title color
                    const splitRemarks = pdf.splitTextToSize(remarks, pdfWidth - 2 * pageMargin);
                    // Center remarks horizontally
                    const remarksTextWidth = pdf.getTextWidth(splitRemarks[0] || ''); // Get width of the first line for centering
                    const centerX = (pdfWidth - remarksTextWidth) / 2;
                    pdf.text(splitRemarks, centerX, remarksYPos); // Add remarks text
                }

                // Add page number at the bottom
                pdf.setFontSize(10);
                pdf.setTextColor(150);
                // Position page number relative to the bottom margin
                pdf.text('Page ' + data.pageNumber, pdfWidth - pageMargin, pdfHeight - pageMargin, { align: 'right' });
            }
            // didParseData is not needed
        });

        pdf.save("Dispatch_dashboard.pdf");
    }

    // Removed Chart Interactivity Functions (handleChartClick, clearChartFilters)
    // Removed the view selector event listener at the end of the script block

</script>

</body>
</html>
