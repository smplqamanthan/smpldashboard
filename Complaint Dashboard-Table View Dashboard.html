<!DOCTYPE html>
<html>
<head>
<title>Complaint Dashboard</title>
<style>
    body {
        font-family: sans-serif;
        margin: 0; /* Remove default body margin */
        padding: 20px; /* Add padding to body */
        background-color: #D0F0C0; /* Light gray background */
    }

    .container {
        max-width: 1200px; /* Max width for content */
        margin: 0 auto; /* Center the container */
        background-color: #fff; /* White background for container */
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Subtle shadow */
        border-radius: 8px;
    }

    .dashboard-header {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        border-bottom: 2px solid #eee;
        padding-bottom: 15px;
    }

    .dashboard-header img {
        height: 60px; /* Adjusted logo size */
        width: auto;
        margin-right: 15px;
    }

    .company-name {
        font-size: 1.8em; /* Larger company name */
        font-weight: bold;
        color: #000080;
        margin: 0;
    }

    .dashboard-title {
        font-size: 1.5em; /* Dashboard title size */
        margin-top: 15px;
        margin-bottom: 20px;
        color: #555;
        text-align: center;
    }

#supabaseLoadButtons button {
    color: #333;
    background-color: #fd7e14; /* A standard blue color */
    border: 1px solid #fd7e14; /* Add a matching border */
    padding: 8px 15px; /* Adjust padding to match other buttons */
    border-radius: 4px; /* Match border-radius */
    cursor: pointer;
    font-size: 14px; /* Match font size */
    /* You might want a hover effect too */
    font-weight: bold; /* Make the text bold */
    transition: background-color 0.2s ease; /* Smooth transition on hover */
}

#supabaseLoadButtons button:hover {
    background-color: #e06b0d; /* Darker blue on hover */
    border-color: #cc5f0b; /* Darker border on hover */
}

    #controls {
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 15px; /* Space between controls */
        flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
    }

    /* Style for the combined layout, width, alignment, and reorder controls group */
   #layoutAndWidthControls {
       display: flex;
       align-items: center;
       gap: 15px; /* Space between the control groups */
       flex-wrap: wrap; /* Allow groups to wrap within the span */
       flex-grow: 1; /* Allow this section to grow */
   }

/* Add this CSS inside your <style> tags */
#layoutControlsContent > span:first-child,
#widthControlsContent > span:first-child,
#pdfRemarksInputContainer label,
#alignmentControlsContent > span:first-child {
    font-weight: bold; /* Optional: Make the text bold */
    color: #0056b3; /* Example color: Dark blue */
    /* You can change #0056b3 to any color code you prefer */
}

   /* Style for individual control groups (Layout, Width, Alignment) */
    #layoutControlsContent, #widthControlsContent, #alignmentControlsContent { /* Target the new span IDs */
        display: flex;
        align-items: center;
        gap: 10px;
        border: 1px solid #ccc;
        padding: 8px;
        border-radius: 4px;
        background-color: #f9f9f9;
    }
    #layoutControlsContent input[type="text"],
    #layoutControlsContent select,
    #layoutControlsContent button,
    #widthControlsContent select,
    #widthControlsContent input[type="number"],
    #widthControlsContent button,
    #alignmentControlsContent select,
    #alignmentControlsContent button { /* Added alignment controls */
        padding: 5px 10px;
        border: 1px solid #ccc;
        border-radius: 3px;
        font-size: 14px;
    }
    #layoutControlsContent button, #widthControlsContent button, #alignmentControlsContent button { /* Added alignment controls button */
        cursor: pointer;
        background-color: #e0e0e0;
    }
     #layoutControlsContent button:hover, #widthControlsContent button:hover, #alignmentControlsContent button:hover { /* Added hover */
         background-color: #d5d5d5;
     }
    #widthControlsContent input[type="number"] {
        width: 60px; /* Adjust width as needed */
    }

    #fileInputContainer, #applyButtonContainer, #downloadButtons, #reorderControls { /* Included reorderControls */
        display: flex;
        align-items: center;
        gap: 10px;
    }
     #applyButtonContainer button {
         padding: 8px 15px;
         background-color: #007bff;
         color: white;
         border: none;
         border-radius: 4px;
         cursor: pointer;
         font-size: 14px;
     }
     #applyButtonContainer button:hover {
        background-color: #0056b3;
     }
     #downloadButtons button {
         padding: 8px 15px;
         background-color: #28a745;
         color: white;
         border: none;
         border-radius: 4px;
         cursor: pointer;
         font-size: 14px;
     }
      #downloadButtons button.pdf {
          background-color: #dc3545;
      }
     #downloadButtons button:hover {
         opacity: 0.9;
     }
    #reorderControls button { /* Style for reorder button */
         padding: 8px 15px;
         background-color: #ffc107; /* Yellowish */
         color: #333;
         border: none;
         border-radius: 4px;
         cursor: pointer;
         font-size: 14px;
    }
     #reorderControls button:hover {
         background-color: #e0a800;
     }
   
    #pdfRemarksInputContainer { /* Style for remarks input */
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px; /* Add some space above */
        width: 100%; /* Take full width */
        flex-wrap: wrap; /* Allow wrapping */
    }
    #pdfRemarksInputContainer label {
        font-weight: bold;
        font-size: 14px;
    }
    #pdfRemarksInputContainer input[type="text"] {
         flex-grow: 1; /* Allow input to take available space */
         padding: 5px;
         border: 1px solid #ccc;
         border-radius: 3px;
         font-size: 14px;
    }


    /* Container for horizontal scrolling */
    #tableScrollContainer {
        overflow-x: auto;
        margin-top: 20px;
    }

    table {
        border-collapse: collapse;
        /* Remove width: 100%; here to allow table to exceed container width */
        font-size: 14px;
        table-layout: fixed; /* Keep fixed layout for controlled column widths */
        border: 1px solid black; /* Black border around the table */
        min-width: 100%; /* Ensure table takes at least 100% width if content is less */
    }
    th, td {
        border: 1px solid black; /* Black borders between columns and rows */
        padding: 8px;
        text-align: left; /* Default alignment */
        vertical-align: top; /* Align content to the top in cells */
        word-wrap: break-word; /* Allow long words to break */
        white-space: pre-wrap; /* Preserve whitespace and wrap text */
        overflow: hidden; /* Hide overflowing content within the cell */
        text-overflow: ellipsis; /* Add ellipsis for overflowing text */
    }
     th {
         background-color: #e0f7fa; /* Light blue background for headers */
         font-weight: bold;
         position: relative; /* Needed for sort arrows */
         cursor: pointer; /* Indicate sortable */
     }
     th:hover {
         background-color: #b2ebf2; /* Slightly darker blue on hover */
     }
     th .sort-arrow {
         margin-left: 5px;
         font-size: 10px;
     }


    .filter-container {
        margin-bottom: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* Space between filter dropdowns */
    }
    .filter-dropdown {
        position: relative;
        display: inline-block;
        vertical-align: top;
    }
    .dropdown-button {
        padding: 8px 12px;
        cursor: pointer;
        border: 1px solid #007bff; /* Blue border */
        background-color: #007bff; /* Blue background */
        color: white; /* White text */
        border-radius: 4px;
        min-width: 120px;
        text-align: left;
        font-size: 14px;
    }
     .dropdown-button .filter-arrow {
         float: right;
         color: white; /* White arrow */
     }
      .dropdown-button:hover {
          background-color: #0056b3; /* Darker blue on hover */
          border-color: #0056b3;
      }

    .dropdown-content {
        display: none;
        position: absolute;
        background-color: #fff;
        min-width: 220px;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 10;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        max-height: 300px;
        overflow-y: auto;
        top: 100%; /* Position below the button */
        left: 0;
    }
     .dropdown-content .search-container {
         margin-bottom: 8px;
     }
    .dropdown-content input[type="text"] {
        width: calc(100% - 18px);
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 3px;
        box-sizing: border-box;
        margin-bottom: 8px;
        font-size: 14px;
    }
    .dropdown-content .select-all {
        font-weight: bold;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
        margin-bottom: 5px;
        cursor: pointer;
        font-size: 14px;
    }
     .dropdown-content .select-all input[type="checkbox"] {
         margin-right: 5px;
     }
    .dropdown-content .filter-options {
        margin-bottom: 5px; /* Reduced bottom margin */
    }
    .dropdown-content label {
        display: block;
        margin-bottom: 4px;
        cursor: pointer;
        font-weight: normal;
        font-size: 14px;
    }
     .dropdown-actions {
         display: none; /* Hide action buttons within dropdowns */
     }

    /* Styles for the Reorder Panel */
     #reorderPanel {
         position: fixed; /* or absolute */
         top: 50%;
         left: 50%;
         transform: translate(-50%, -50%);
         background-color: #fff;
         padding: 20px;
         border: 1px solid #ccc;
         box-shadow: 0 0 10px rgba(0,0,0,0.5);
         z-index: 100;
         max-height: 80vh;
         overflow-y: auto;
         display: none; /* Initially hidden */
     }
     #columnOrderList {
         list-style: none;
         padding: 0;
         margin: 0 0 15px 0;
     }
     #columnOrderList li {
         margin-bottom: 5px;
         padding: 8px;
         border: 1px solid #eee;
         background-color: #f9f9f9;
         display: flex;
         justify-content: space-between;
         align-items: center;
         font-size: 14px;
     }
     #columnOrderList li button {
         padding: 3px 8px;
         margin-left: 5px;
         cursor: pointer;
     }

</style>
</head>
<body>

<div class="container"> <!-- Main container -->
    <div class="dashboard-header">
        <img src="https://www.sagarmanufacturers.com/assets/web/images/smpl-new-logo.png" alt="Company Logo"
             style="height: 60px; width: auto; margin-right: 15px;">
        <h1 class="company-name">Sagar Manufacturers Pvt. Ltd.</h1>
    </div>
    <!-- Title is now effectively managed by Remarks for PDF -->
    <!-- <h2 class="dashboard-title">Complaint Dashboard</h2> -->

    <div id="controls">
       <div id="supabaseLoadButtons">
    <button id="loadYarnButton">Load Yarn Complaint Data</button>
    <button id="loadFabricButton">Load Fabric Complaint Data</button>
</div>

         <div id="applyButtonContainer">
             <button id="applyFiltersButton" style="display: none;">Apply Filters</button>
         </div>

         <div id="downloadButtons" style="display: none;">
             <span>Download:</span>
             <button id="downloadExcelButton">Excel</button>
             <button id="downloadPdfButton" class="pdf">PDF</button>
         </div>

        <!-- Reorder button moved here -->
        <div id="reorderControls" style="display: none;">
           <button id="showReorderPanelButton">Reorder Columns</button>
       </div>

<div class="flex justify-end p-4">
 <button onclick="goBack()" class="bg-blue-600 font-bold text-white h-fit px-4 py-2 rounded hover:bg-blue-700 mt-6">
    ← Home
  </button>
</div>

        <!-- Combined Layout, Width, and Alignment Controls -->
        <span style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; flex-grow: 1;" id="layoutAndWidthControls">
            <span style="display: flex; align-items: center; gap: 10px; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #f9f9f9; display: none;" id="layoutControlsContent">
                <span>Layout:</span>
                <input type="text" id="layoutNameInput" placeholder="Layout Name">
                <button id="saveLayoutButton">Save</button>
                <select id="loadLayoutSelect">
                    <option value="">- Load Layout -</option>
                </select>
                <button id="loadLayoutButton" disabled>Load</button>
                <button id="deleteLayoutButton" disabled>Delete</button>
            </span>

            <span style="display: flex; align-items: center; gap: 10px; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #f9f9f9; display: none;" id="widthControlsContent">
                <span>Adjust Width:</span>
                <select id="columnSelectForWidth">
                    <option value="">- Select Column -</option>
                </select>
                <input type="number" id="columnWidthValue" value="150" min="10" style="width: 60px;">
                <select id="columnWidthUnit">
                    <option value="px">px</option>
                    <option value="%">%</option>
                    <option value="em">em</option>
                    <option value="cm">cm</option>
                    <option value="mm">mm</option>
                </select>
                <button id="applyColumnWidthButton">Apply</button>
            </span>

             <!-- New Controls for Column Alignment -->
             <span style="display: flex; align-items: center; gap: 10px; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #f9f9f9; display: none;" id="alignmentControlsContent">
                 <span>Align Data:</span>
                 <select id="columnSelectForAlignment">
                     <option value="">- Select Column -</option>
                 </select>
                 <select id="columnAlignmentValue">
                     <option value="left">Left</option>
                     <option value="center">Center</option>
                     <option value="right">Right</option>
                 </select>
                 <button id="applyColumnAlignmentButton">Apply</button>
             </span>


        </span>
        <!-- PDF Remarks Input -->
        <div id="pdfRemarksInputContainer" style="display: none; margin-top: 10px; width: 100%;">
             <label for="pdfRemarksInput">Remarks/Title for PDF:</label>
             <input type="text" id="pdfRemarksInput" placeholder="Enter remarks or title for PDF..." style="flex-grow: 1; padding: 5px;">
        </div>
    </div>

    <div id="filtersContainer" class="filter-container">
        <!-- Filter dropdowns and Column Visibility dropdown will be generated here by JavaScript -->
    </div>

    <!-- Wrapper for table scrolling -->
    <div id="tableScrollContainer">
        <div id="tableContainer">
            <!-- Table will be generated here by JavaScript -->
        </div>
    </div>

</div> <!-- End Main container -->

<!-- Column Reordering Panel (initially hidden) -->
<div id="reorderPanel" style="display: none;
    position: fixed; /* or absolute */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    padding: 20px;
    border: 1px solid #ccc;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    z-index: 100;
    max-height: 80vh;
    overflow-y: auto;">
    <h3>Reorder Columns</h3>
    <ul id="columnOrderList" style="list-style: none; padding: 0;">
        <!-- Column items will be added here by JS -->
    </ul>
    <button id="applyReorderButton">Apply Order</button>
    <button id="cancelReorderButton">Cancel</button>
</div>


<!-- CDN for SheetJS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<!-- CDNs for html2canvas and jsPDF + autoTable -->
<!-- jsPDF v2.x -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<!-- jsPDF-AutoTable plugin (explicitly added to ensure it's available) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>
<!-- html2canvas is still used by downloadPdf for capturing the logo image as data URL -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>


<script>
    // Ensure the DOM is fully loaded before adding event listeners
    document.addEventListener('DOMContentLoaded', function() {

        document.getElementById('loadYarnButton').addEventListener('click', loadYarnData, false);
        document.getElementById('loadFabricButton').addEventListener('click', loadFabricData, false);
        document.getElementById('applyFiltersButton').addEventListener('click', applyFilters, false);
        document.getElementById('downloadExcelButton').addEventListener('click', downloadExcel, false);
        document.getElementById('downloadPdfButton').addEventListener('click', downloadPdf, false);

        // Layout Control Event Listeners
        document.getElementById('saveLayoutButton').addEventListener('click', saveLayout, false);
        document.getElementById('loadLayoutSelect').addEventListener('change', enableLayoutButtons, false);
        document.getElementById('loadLayoutButton').addEventListener('click', loadLayout, false);
        document.getElementById('deleteLayoutButton').addEventListener('click', deleteLayout, false);

        // Column Width Adjustment Event Listener
        document.getElementById('applyColumnWidthButton').addEventListener('click', applyColumnWidth, false);

        // Column Alignment Adjustment Event Listener
        document.getElementById('applyColumnAlignmentButton').addEventListener('click', applyColumnAlignment, false);


        // Column Reordering Event Listeners
        document.getElementById('showReorderPanelButton').addEventListener('click', showReorderPanel, false);
        document.getElementById('applyReorderButton').addEventListener('click', applyReorder, false);
        document.getElementById('cancelReorderButton').addEventListener('click', hideReorderPanel, false);

         // Initial load of saved layouts on page load
    
         loadSavedLayoutNames();
         enableLayoutButtons(); // Set initial button states


    }); // End DOMContentLoaded listener


    // Helper function to convert Excel date serial number (assuming 1900 system) to JavaScript Date
    // This provides an alternative if SSF.parse_date_code is not working.
    // Based on common implementations, accounts for Excel's leap year bug in 1900.
function excelDateToJSDate(excelDate, is1904System = false) {
    // Based on SheetJS recommendations for robust conversion
    if (excelDate === null || excelDate === undefined || typeof excelDate !== 'number' || excelDate <= 0) {
         // Return null or handle non-valid number dates
        return null;
    }

    const MS_PER_DAY = 24 * 60 * 60 * 1000;
    let date;

    // Excel dates are days since 1899-12-31 (for 1900 system) or 1904-01-01 (for 1904 system)
    // SheetJS recommends using Date.UTC(1899, 11, 30) as a base (1899-12-30 UTC) for the 1900 system.
    // The difference between a serial number in 1900 vs 1904 system for the same date is 1462 days.
    // So, to convert a 1904 serial to its equivalent 1900 serial base, we add 1462.

    let baseDate = Date.UTC(1899, 11, 30); // 1899-12-30 UTC (base for 1900 system)

    if (is1904System) {
        // If using 1904 system, the effective base is 1462 days later
        baseDate += 1462 * MS_PER_DAY;
    }

    // Create JS Date from milliseconds since Unix epoch (1970-01-01Z)
    // The Excel serial represents days since its epoch.
    // We add the total milliseconds (serial * MS_PER_DAY) to the effective base date milliseconds.
     const dateMillis = baseDate + excelDate * MS_PER_DAY;
     date = new Date(dateMillis);


    // The Excel 1900 leap year bug: Excel incorrectly treats 1900 as a leap year, including Feb 29, 1900.
    // This means for dates from March 1, 1900 onwards in the 1900 system, Excel's serial numbers
    // are one day higher than the actual number of days since 1900-01-01 (excluding the fake leap day).
    // If using the 1900 system AND the original serial is > 60 (meaning the date is 1900-03-01 or later in Excel's 1900 system),
    // the calculated JS date will be one day ahead of the correct date. We need to subtract that day.
    // This adjustment is relative to the 1900 system serial number.
    if (!is1904System && excelDate > 60) {
       date.setDate(date.getDate() - 1);
    }


     // Final check for validity
    if (isNaN(date.getTime())) {
        console.warn(`Converted date is invalid for serial: ${excelDate}`);
        return null;
    }

    return date;
}

    // Define which columns should have data filters (alphabetically sorted later)
    const dataFilterableColumnNames = [
        'RECEIVE YEAR',
        'RECEIVE MONTH', // Added month filter
        'STATUS',
        'CUSTOMER NAME',
        'YARN LOT NO',
        'UNIT NO',
        'CUSTOMER TYPE',
        'TYPE OF COMPLAINT',
        'COTTON',
        'COMPLAINT OR FEEDBACK',
        'MFG YEAR',
        'COUNT'
    ].sort(); // Sort data filterable columns alphabetically


    let tableData = []; // Store the original data objects (keys are original headers)
    let columnNamesFromExcel = []; // Store the exact column names read from the Excel header
    let currentAppliedDataFilters = {}; // Store the data filters currently applied to the table
    let visibleColumns = []; // Store which columns are currently visible (subset of columnNamesFromExcel)
    let currentSort = { column: null, direction: 'none' }; // State for current sorting
    let columnWidths = {}; // Store custom column widths (using cleaned column names as keys, storing strings like "500px")
    let columnDisplayOrder = []; // Store the desired order of ALL columns
    let columnAlignments = {}; // Store custom column alignments (using cleaned column names as keys, storing strings like "center")

// Supabase Storage Public URLs
const YARN_DATA_URL = 'https://jdajahcjljvnkopfdrpi.supabase.co/storage/v1/object/public/complaint//Fabric%20Complaint%20Data';
const FABRIC_DATA_URL = 'https://jdajahcjljvnkopfdrpi.supabase.co/storage/v1/object/public/complaint//Yarn%20Complaint%20Data';

// Helper function to process the fetched Excel data
async function processExcelData(arrayBuffer) {
    const data = new Uint8Array(arrayBuffer);
    const workbook = XLSX.read(data, { type: 'array' });

    const firstSheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[firstSheetName];

    // Convert the worksheet data to an array of arrays, keeping raw values for date conversion
    // Use defval: '' to set undefined values to empty string
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: true, defval: '' });

    // Assume the first row of jsonData is the header
    const header = jsonData[0];
    const dataRows = jsonData.slice(1);

    // Store column names directly from the header, clean them, and ensure uniqueness
    columnNamesFromExcel = []; // Ensure re-initialization on new file load
    const seenNames = new Set();
    if (header) { // Ensure header is not null or undefined
        header.forEach(colName => {
            const cleanedName = colName ? String(colName).trim() : `Unnamed Column_${seenNames.size}`; // Use size for unique unnamed
            let uniqueName = cleanedName;
            let counter = 1;
            // Handle duplicate column names by appending a number
            while(seenNames.has(uniqueName)) {
                uniqueName = `<span class="math-inline">\{cleanedName\}\_</span>{counter}`;
                counter++;
            }
            columnNamesFromExcel.push(uniqueName);
            seenNames.add(uniqueName);
        });
    } else {
        console.warn("No header row found in the Excel file.");
         // Generate some default column names if no header
         const numCols = dataRows[0] ? dataRows[0].length : 0;
         for(let i = 0; i < numCols; i++) {
             columnNamesFromExcel.push(`Column${i+1}`);
         }
    }


    // Map data rows to objects using the cleaned header names as keys
    tableData = dataRows.map(row => {
        const rowObject = {};
        columnNamesFromExcel.forEach((colName, index) => { // Use cleaned header names as keys
            let cellValue = row[index];

            // --- Date Formatting for 'QUERY RECEIVED DATE' ---
            // Check if the cleaned column name matches 'QUERY RECEIVED DATE' (case-insensitive)
            if (colName.toLowerCase() === 'query received date') { // Focus on this column using cleaned name
                // Check if it's a positive number, which is expected for Excel date serials
                if (typeof cellValue === 'number' && cellValue > 0) {
                    try {
                        // Use the custom helper function for conversion
                        const date = excelDateToJSDate(cellValue); // Revert to assuming 1900 system (or false)

                        if (date instanceof Date && !isNaN(date) && date !== null) { // Check if it's a valid and non-null Date object
                            // Format date to dd-mm-yy
                            const day = date.getDate().toString().padStart(2, '0');
                            const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
                            const year = date.getFullYear().toString().slice(-2); // Get last two digits of year
                            cellValue = `${day}-${month}-${year}`;
                            //console.log(`Formatted date: ${cellValue}`); // Debug log
                            } else {
                           // If conversion results in invalid or null date, use original value as string
                           cellValue = String(cellValue);
                        }
                    } catch (e) {
                        // Handle potential errors during date conversion
                        console.error(`Error during date conversion for value: ${cellValue}`, e);
                        cellValue = String(cellValue); // Fallback to original value string
                    }
                } else {
                    // If it's not a positive number, it's not a standard Excel date serial, treat as string
                    cellValue = cellValue !== undefined && cellValue !== null ? String(cellValue) : '';
                }
            } else {
                // Ensure other values are treated as strings for filtering and display if not already
                cellValue = cellValue !== undefined && cellValue !== null ? String(cellValue) : '';
            }
            // --- End Date Formatting ---

            rowObject[colName] = cellValue; // Use the cleaned column name as the key
        });
        return rowObject; // Return the object with keys as column names
    });


    // Initialize filters (both data filters and column visibility filter)
    initializeFilters(tableData, columnNamesFromExcel); // Pass all column names for filters

    // Initialize applied data filters to empty, and visible columns to all excel columns
    currentAppliedDataFilters = {}; // Reset applied filters
    dataFilterableColumnNames.forEach(col => {
         // Ensure the filterable column exists in the excel file's columns (case-insensitive)
         if (columnNamesFromExcel.some(name => name.toLowerCase() === col.toLowerCase())) {
             currentAppliedDataFilters[col] = [];
         }
     });
    visibleColumns = [...columnNamesFromExcel]; // Reset visible columns
    currentSort = { column: null, direction: 'none' }; // Reset sort state on new file
    columnWidths = {}; // Reset column widths on new file unless loading layout
    columnDisplayOrder = [...columnNamesFromExcel]; // Initialize display order to match file order
    columnAlignments = {}; // Initialize column alignments to empty (defaults to left)


    // Display the initial table
    applyFilters(); // This function now handles data filtering, column visibility, and sorting

    // Show controls
    document.getElementById('applyFiltersButton').style.display = 'inline-block';
    document.getElementById('downloadButtons').style.display = 'flex';
    document.getElementById('layoutControlsContent').style.display = 'flex'; // Show layout controls content
    document.getElementById('widthControlsContent').style.display = 'flex'; // Show width controls content
    document.getElementById('alignmentControlsContent').style.display = 'flex'; // Show alignment controls content
    document.getElementById('reorderControls').style.display = 'block'; // Show reorder controls button
    document.getElementById('pdfRemarksInputContainer').style.display = 'flex'; // Show remarks input


    // Load saved layouts for the new file
    loadSavedLayoutNames(); // Call this after populating columnNamesFromExcel
    populateColumnWidthSelect(); // Populate the column select for width adjustment
    populateColumnAlignmentSelect(); // Populate the column select for alignment
}


async function loadYarnData() {
    console.log('Attempting to load Yarn Complaint Data...');
    try {
        const response = await fetch(YARN_DATA_URL);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const arrayBuffer = await response.arrayBuffer();
        console.log('Yarn data fetched successfully.');

        await processExcelData(arrayBuffer); // Process the fetched data

    } catch (error) {
        console.error('Error loading Yarn Complaint Data:', error);
        alert('Failed to load Yarn Complaint Data. Please check the URL and your network connection.');
        // Optionally clear the table or show an error message in the UI
        document.getElementById('tableContainer').innerHTML = '<p>Error loading data.</p>';
         // Hide controls if data loading fails
        document.getElementById('applyFiltersButton').style.display = 'none';
        document.getElementById('downloadButtons').style.display = 'none';
        document.getElementById('layoutControlsContent').style.display = 'none';
        document.getElementById('widthControlsContent').style.display = 'none';
        document.getElementById('alignmentControlsContent').style.display = 'none';
        document.getElementById('reorderControls').style.display = 'none';
        document.getElementById('pdfRemarksInputContainer').style.display = 'none';
    }
}

async function loadFabricData() {
     console.log('Attempting to load Fabric Complaint Data...');
    try {
        const response = await fetch(FABRIC_DATA_URL);

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const arrayBuffer = await response.arrayBuffer();
        console.log('Fabric data fetched successfully.');

        await processExcelData(arrayBuffer); // Process the fetched data

    } catch (error) {
        console.error('Error loading Fabric Complaint Data:', error);
         alert('Failed to load Fabric Complaint Data. Please check the URL and your network connection.');
        // Optionally clear the table or show an error message in the UI
        document.getElementById('tableContainer').innerHTML = '<p>Error loading data.</p>';
         // Hide controls if data loading fails
        document.getElementById('applyFiltersButton').style.display = 'none';
        document.getElementById('downloadButtons').style.display = 'none';
        document.getElementById('layoutControlsContent').style.display = 'none';
        document.getElementById('widthControlsContent').style.display = 'none';
        document.getElementById('alignmentControlsContent').style.display = 'none';
        document.getElementById('reorderControls').style.display = 'none';
        document.getElementById('pdfRemarksInputContainer').style.display = 'none';
    }
}


     function initializeFilters(data, allColumnNames) { // Accept all column names
         const filtersContainer = document.getElementById('filtersContainer');
         filtersContainer.innerHTML = ''; // Clear previous filters

         // --- Create Column Visibility Filter ---
         const columnVisibilityDropdownHtml = `
             <div class="filter-dropdown" data-filter-type="visibility">
                 <button class="dropdown-button">Show/Hide Columns <span class="filter-arrow">&#9662;</span></button>
                 <div class="dropdown-content">
                     <div class="search-container">
                          <input type="text" class="column-search" placeholder="Search...">
                     </div>
                     <label class="select-all">
                          <input type="checkbox" class="select-all-columns-checkbox" checked> Select All
                     </label>
                     <div class="column-options filter-options"> <!-- Use filter-options class for consistent styling -->
                         ${allColumnNames.map(colName => `
                             <label>
                                 <input type="checkbox" class="column-checkbox" value="${colName}" checked> ${colName}
                             </label>
                         `).join('')}
                     </div>
                 </div>
             </div>
         `;
         filtersContainer.innerHTML += columnVisibilityDropdownHtml;


         // --- Create Data Filters ---
         dataFilterableColumnNames.forEach(columnName => {
             // Check if this filterable column exists in the actual Excel columns (case-insensitive match)
              if (allColumnNames.some(name => name.toLowerCase() === columnName.toLowerCase())) {
                 // Get unique values from the loaded data for this specific column name
                 // Need to find the exact casing from the loaded columns to get data correctly
                 const exactColumnName = allColumnNames.find(name => name.toLowerCase() === columnName.toLowerCase());
                 let uniqueValues = [...new Set(data.map(row => row[exactColumnName] !== undefined && row[exactColumnName] !== null ? String(row[exactColumnName]) : '').filter(value => value !== ''))];

                  // --- Custom Sorting for Month Columns ---
                  if (columnName.toLowerCase() === 'receive month' || columnName.toLowerCase() === 'mfg month') {
                      uniqueValues.sort((a, b) => {
                          const numA = parseInt(a);
                          const numB = parseInt(b);
                          // Handle cases where conversion to number fails or is NaN
                          if (isNaN(numA) && isNaN(numB)) return 0;
                          if (isNaN(numA)) return 1; // Put non-numeric at the end
                          if (isNaN(numB)) return -1; // Put non-numeric at the end
                          return numA - numB; // Numeric sort
                      });
                  } else {
                      // Default to alphabetical sort for other columns
                      uniqueValues.sort();
                  }
                  // --- End Custom Sorting ---


                 if (uniqueValues.length > 0) {
                     const filterDropdownHtml = `
                          <div class="filter-dropdown" data-column="${columnName}" data-filter-type="data">
                              <button class="dropdown-button">${columnName} <span class="filter-arrow">&#9662;</span></button>
                              <div class="dropdown-content">
                                  <div class="search-container">
                                      <input type="text" class="filter-search" placeholder="Search...">
                                   </div>
                                   <label class="select-all">
                                       <input type="checkbox" class="select-all-checkbox"> Select All
                                   </label>
                                   <div class="filter-options">
                                       ${uniqueValues.map(value => `
                                           <label>
                                                <input type="checkbox" class="filter-checkbox" value="${value}"> ${value}
                                           </label>
                                       `).join('')}
                                   </div>
                              </div>
                          </div>
                      `;
                     filtersContainer.innerHTML += filterDropdownHtml;
                 }
              }
         });


         // Add event listeners to the newly created filter elements
         addFilterEventListeners();
     }
function goBack() {
    window.location.href = "https://pankajmehta28.github.io/my-dashboard/protected.html";
  }

    function addFilterEventListeners() {
        document.querySelectorAll('.filter-dropdown').forEach(dropdown => {
            const button = dropdown.querySelector('.dropdown-button');
            const content = dropdown.querySelector('.dropdown-content');
            const searchInput = dropdown.querySelector('.filter-search') || dropdown.querySelector('.column-search'); // Get search input for either type
            const selectAllCheckbox = dropdown.querySelector('.select-all-checkbox') || dropdown.querySelector('.select-all-columns-checkbox'); // Get select all for either type
            const optionsContainer = dropdown.querySelector('.filter-options'); // Checkboxes container

            const filterType = dropdown.getAttribute('data-filter-type');
            const columnName = dropdown.getAttribute('data-column'); // For data filters


            // Toggle dropdown visibility
            button.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent window click from closing immediately
                // Close other open dropdowns
                document.querySelectorAll('.dropdown-content').forEach(openContent => {
                    if (openContent !== content) {
                        openContent.style.display = 'none';
                    }
                });
                // Toggle current dropdown
                content.style.display = content.style.display === 'block' ? 'none' : 'block';

                 // When opening, ensure checkboxes reflect current state (applied data filters or visible columns)
                 if (content.style.display === 'block') {
                     let currentStateValues = [];
                     if (filterType === 'data') {
                         currentStateValues = currentAppliedDataFilters[columnName] || [];
                     } else if (filterType === 'visibility') {
                         currentStateValues = visibleColumns;
                     }

                     optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                         checkbox.checked = currentStateValues.includes(checkbox.value);
                     });
                      // Update select all checkbox state on opening
                     updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                 }
            });

            // Prevent clicks inside the dropdown content from closing it
             content.addEventListener('click', (event) => {
                 event.stopPropagation();
             });

            // Search functionality
            if (searchInput) { // Ensure search input exists
                 searchInput.addEventListener('input', () => {
                     const searchTerm = searchInput.value.toLowerCase();
                     optionsContainer.querySelectorAll('label').forEach(label => {
                         const text = label.textContent.toLowerCase();
                         label.style.display = text.includes(searchTerm) ? 'block' : 'none';
                     });
                      // After filtering search results, update the "Select All" checkbox state
                      updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                 });
            }


            // Select/Unselect All functionality
             if (selectAllCheckbox) { // Ensure select all checkbox exists
                 selectAllCheckbox.addEventListener('change', (event) => {
                      optionsContainer.querySelectorAll('label').forEach(label => {
                         // Only affect checkboxes of currently visible labels after search
                         if(label.style.display !== 'none') {
                           label.querySelector('input[type="checkbox"]').checked = event.target.checked;
                         }
                      });
                      // Update the state of the Select All checkbox itself (handles indeterminate)
                      updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                      // Note: Filters are applied ONLY on clicking the main Apply button now.
                 });
             }


             // Individual checkbox change listener
             optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => { // Iterate over each checkbox
                 checkbox.addEventListener('change', () => {
                     updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                      // Note: Filters are applied ONLY on clicking the main Apply button now.
                 });
             });
        });

        // Close dropdowns when clicking outside the dropdown container
         window.addEventListener('click', (event) => {
             document.querySelectorAll('.filter-dropdown').forEach(dropdown => {
                 const content = dropdown.querySelector('.dropdown-content');
                 // Use !dropdown.contains(event.target) which is simpler and safer
                 if (!dropdown.contains(event.target)) {
                     content.style.display = 'none';
                      // When closing by clicking outside, reset checkboxes in open dropdowns
                      // to the currently applied filter state before closing.
                     const filterType = dropdown.getAttribute('data-filter-type');
                     const optionsContainer = dropdown.querySelector('.filter-options');
                     const selectAllCheckbox = dropdown.querySelector('.select-all-checkbox') || dropdown.querySelector('.select-all-columns-checkbox');

                     let currentStateValues = [];
                     if (filterType === 'data') {
                          const columnName = dropdown.getAttribute('data-column');
                          currentStateValues = currentAppliedDataFilters[columnName] || [];
                     } else if (filterType === 'visibility') {
                          currentStateValues = visibleColumns;
                     }

                     optionsContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                         checkbox.checked = currentStateValues.includes(checkbox.value);
                     });
                     updateSelectAllCheckbox(optionsContainer, selectAllCheckbox);
                 }
             });
         });
    }

    // Helper to update the state of the "Select All" checkbox (Handles indeterminate state)
    function updateSelectAllCheckbox(optionsContainer, selectAllCheckbox) {
        if (!selectAllCheckbox) return; // Handle cases where select all might not exist

        const visibleCheckboxes = Array.from(optionsContainer.querySelectorAll('label'))
                                           .filter(label => label.style.display !== 'none')
                                           .map(label => label.querySelector('input[type="checkbox"]'));

        const checkedVisibleCheckboxes = visibleCheckboxes.filter(cb => cb.checked);

         if (visibleCheckboxes.length === 0) {
              selectAllCheckbox.checked = false;
              selectAllCheckbox.indeterminate = false;
         } else if (checkedVisibleCheckboxes.length === visibleCheckboxes.length) {
             selectAllCheckbox.checked = true;
             selectAllCheckbox.indeterminate = false;
         } else if (checkedVisibleCheckboxes.length > 0) {
             selectAllCheckbox.checked = false; // It's not 'all' if some are unchecked
             selectAllCheckbox.indeterminate = true; // But some are checked
         }
          else { // No visible checkboxes are checked
             selectAllCheckbox.checked = false;
             selectAllCheckbox.indeterminate = false;
          }
    }

    // Function to apply filters based on current selections in all dropdowns
    function applyFilters() {
        // --- Collect Data Filter Selections ---
        dataFilterableColumnNames.forEach(columnName => {
            // Find the dropdown for this data filterable column
            const dropdown = document.querySelector(`.filter-dropdown[data-column="${columnName}"][data-filter-type="data"]`);
            if (dropdown) {
                 const selectedValues = [];
                 dropdown.querySelectorAll('.filter-options .filter-checkbox:checked').forEach(checkbox => {
                     selectedValues.push(checkbox.value);
                 });
                 currentAppliedDataFilters[columnName] = selectedValues; // Update the globally applied data filters
            } else {
                 // If a filterable column does not have a dropdown (e.g., no unique values),
                 // ensure its filter is also reset or empty in the applied state
                 currentAppliedDataFilters[columnName] = [];
            }
        });

         // --- Collect Column Visibility Selections ---
         const selectedVisibleColumns = [];
         const visibilityDropdown = document.querySelector('.filter-dropdown[data-filter-type="visibility"]');
         if (visibilityDropdown) {
             visibilityDropdown.querySelectorAll('.column-options .column-checkbox:checked').forEach(checkbox => {
                  selectedVisibleColumns.push(checkbox.value);
             });
         }
         visibleColumns = selectedVisibleColumns; // Update the globally visible columns

        // --- Apply Data Filters ---
        let filteredData = tableData;

        dataFilterableColumnNames.forEach(columnName => {
            const selectedValues = currentAppliedDataFilters[columnName]; // Use currently applied data filters
            if (selectedValues && selectedValues.length > 0) {
                filteredData = filteredData.filter(row => {
                     // Find the actual key in the row object based on the filter column name (case-insensitive)
                     const rowKey = Object.keys(row).find(key => key.toLowerCase() === columnName.toLowerCase());
                     if (rowKey) {
                         const rowValue = row[rowKey] !== undefined && row[rowKey] !== null ? String(row[rowKey]) : '';
                         return selectedValues.includes(rowValue);
                     }
                     return false; // If the filter column doesn't exist in the row, filter it out
                });
            }
        });

        // --- Apply Sorting ---
        // Sorting logic remains, but the click handler prevents sorting during resize (though resizing is removed now)
        if (currentSort.column) {
            const sortColumnName = currentSort.column;
            const sortDirection = currentSort.direction;

             // Find the actual column name in the data based on the sortColumnName (case-insensitive)
             const actualSortColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === sortColumnName.toLowerCase());

            if (actualSortColumnName) {
                 filteredData.sort((a, b) => {
                     const aValue = a[actualSortColumnName] !== undefined && a[actualSortColumnName] !== null ? String(a[actualSortColumnName]) : '';
                     const bValue = b[actualSortColumnName] !== undefined && b[actualSortColumnName] !== null ? String(b[actualSortColumnName]) : '';

                      // Special handling for month columns for sorting
                      if (actualSortColumnName.toLowerCase() === 'receive month' || actualSortColumnName.toLowerCase() === 'mfg month') {
                           const numA = parseInt(aValue);
                           const numB = parseInt(bValue);
                            if (isNaN(numA) && isNaN(numB)) return 0;
                            if (isNaN(numA)) return 1;
                            if (isNaN(numB)) return -1;
                            return sortDirection === 'asc' ? numA - numB : numB - numA; // Use numB - numA for desc
                      }


                     // Basic string comparison for sorting for other columns
                     if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
                     if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
                     return 0; // Values are equal
                 });
            }
        }

        // --- Display the table with filtered data and selected columns ---
        displayTable(filteredData, visibleColumns);

        // Update the column select dropdowns for width and alignment after displaying
        populateColumnWidthSelect();
        populateColumnAlignmentSelect();
    }


    function displayTable(data, columnsToDisplay) {
        const tableContainer = document.getElementById('tableContainer');
        tableContainer.innerHTML = ''; // Clear previous table

        // Check if there is data to display and columns selected
        // Note: We iterate based on columnDisplayOrder, but check if it's in visibleColumns
        const columnsToRender = columnDisplayOrder.filter(col =>
            visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())
        );


        if (data.length > 0 && columnsToRender.length > 0) {
            let html = '<table>';

            // Add colgroup for fixed column widths
            html += '<colgroup>';
            // Iterate through the display order, but only add cols for visible columns
            columnDisplayOrder.forEach(col => {
                 // Check if this column is in the currently visible columns list (case-insensitive)
                 if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                    // Find the corresponding actual column name from Excel header (case-insensitive) to get width
                    const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                    if (actualColumnName) {
                         let colWidth = columnWidths[actualColumnName]; // Get saved width first

                         // If no saved width, apply default width
                         if (!colWidth) {
                             // Apply default widths based on the actual column name
                             if (actualColumnName === 'ANALYSIS AND OUTCOME' || actualColumnName === 'ACTION TAKEN') {
                                colWidth = '700px'; // Increased Default Wider Width
                             } else if (actualColumnName.toLowerCase() === 'query received date') {
                                colWidth = '120px'; // Default for date
                             } else if (actualColumnName.toLowerCase() === 'unit no' || actualColumnName.toLowerCase() === 'status' || actualColumnName.toLowerCase() === 'cotton' || actualColumnName.toLowerCase() === 'count' || actualColumnName.toLowerCase() === 'mfg year' || actualColumnName.toLowerCase() === 'receive year' || actualColumnName.toLowerCase() === 'receive month' || actualColumnName.toLowerCase() === 'mfg month') { // Added month columns here
                                colWidth = '80px'; // Default for smaller columns
                             } else {
                                colWidth = '150px'; // General default width
                             }
                             // Store the determined default width as a string (optional, but keeps columnWidths updated)
                             // columnWidths[actualColumnName] = colWidth; // Be careful if loading layouts overwrites
                         }

                         // Use the column name from columnDisplayOrder for the col element's data attribute
                         html += `<col data-column-name="${col}" style="width: ${colWidth};">`;
                    }
                 }
            });
            html += '</colgroup>';


            html += '<thead><tr>';
            // Add headers for the selected columns based on the display order
            columnDisplayOrder.forEach(col => {
                 // Only add header if the column is currently visible (case-insensitive)
                 if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                    // Find the corresponding actual column name from Excel header (case-insensitive) to use for data attribute
                    const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                    if (actualColumnName) {
                         let sortArrow = '';
                         if (currentSort.column && currentSort.column.toLowerCase() === col.toLowerCase()) { // Match sort state using the column from displayOrder
                             sortArrow = currentSort.direction === 'asc' ? ' &#9650;' : ' &#9660;'; // Up/Down arrow
                         }
                         // Apply header alignment from columnAlignments
                         const headerAlignment = columnAlignments[actualColumnName] || 'left'; // Default header alignment to left
                         html += `<th data-column-name="${col}" style="text-align: ${headerAlignment};">${col}<span class="sort-arrow">${sortArrow}</span></th>`; // Use column from displayOrder for header text and data attribute
                    }
                 }
            });
            html += '</tr></thead><tbody>';

            // Add rows for the filtered data, showing only selected columns in the specified display order
            data.forEach(row => {
                html += '<tr>';
                // Iterate through the display order
                columnDisplayOrder.forEach(col => {
                    // Only add td if the column is currently visible (case-insensitive)
                    if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                        // Find the actual key in the row object based on the column name from the display order (case-insensitive)
                        const rowKey = Object.keys(row).find(key => key.toLowerCase() === col.toLowerCase());
                        const cellValue = rowKey ? row[rowKey] : ''; // Use empty string if column data is missing
                        // Apply cell alignment from columnAlignments
                         const actualColName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase()); // Find actual name for alignment lookup
                         const cellAlignment = actualColName ? columnAlignments[actualColName] : 'left'; // Default cell alignment to left

                        html += `<td style="text-align: ${cellAlignment};">${cellValue}</td>`;
                    }
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            tableContainer.innerHTML = html;

             // Add sorting event listeners to the new headers
             addSortEventListeners();


        } else if (columnsToRender.length === 0) {
             tableContainer.innerHTML = '<p>No columns selected to display.</p>';
        }
        else {
            tableContainer.innerHTML = '<p>No data matches the current filter criteria.</p>';
        }
         // Update the column select dropdowns for width and alignment after displaying
         populateColumnWidthSelect();
         populateColumnAlignmentSelect();
    }

    // --- Sorting Functionality ---
     function addSortEventListeners() {
         document.querySelectorAll('#tableContainer th').forEach(header => {
             // Remove existing listeners to prevent duplicates
             // Using removeEventListener with the same function reference works.
             // We need a way to store the *specific* handler function for this header.
             // The data-sort-handler approach using window object is one way,
             // another is to store the function reference directly on the header element's dataset.

             // Remove previous listener if it exists
              if (header.dataset.sortHandlerRef) {
                 header.removeEventListener('click', header.dataset.sortHandlerRef);
                 delete header.dataset.sortHandlerRef;
              }

              const clickHandler = () => {
                 const columnName = header.getAttribute('data-column-name'); // Use column name from display order
                 let newDirection = 'asc';

                 if (currentSort.column === columnName) {
                     if (currentSort.direction === 'asc') {
                         newDirection = 'desc';
                     } else if (currentSort.direction === 'desc') {
                          newDirection = 'none'; // Cycle to no sort
                     } else {
                         newDirection = 'asc'; // From none to asc
                     }
                 }

                 if (newDirection === 'none') {
                     currentSort = { column: null, direction: 'none' };
                 } else {
                      currentSort = { column: columnName, direction: newDirection };
                 }

                 applyFilters(); // Re-apply filters, which now includes sorting
              };

              // Store the handler function reference on the element's dataset
              header.dataset.sortHandlerRef = clickHandler;
              header.addEventListener('click', clickHandler);
         });
     }

    // --- Column Reordering Functionality ---

    function showReorderPanel() {
        if (columnNamesFromExcel.length === 0) {
            alert("Please load an Excel file first to reorder columns.");
            return;
        }
        const list = document.getElementById('columnOrderList');
        list.innerHTML = ''; // Clear current list

        // Populate the list with current display order
        columnDisplayOrder.forEach(colName => {
            const listItem = document.createElement('li');
            listItem.setAttribute('data-column-name', colName);
            listItem.style.marginBottom = '5px';
            listItem.style.padding = '8px';
            listItem.style.border = '1px solid #eee';
            listItem.style.backgroundColor = '#f9f9f9';
            listItem.style.display = 'flex';
            listItem.style.justifyContent = 'space-between';
            listItem.style.alignItems = 'center';
            listItem.style.cursor = 'grab'; // Indicate draggable (optional, if implementing drag/drop later)

            const colNameSpan = document.createElement('span');
            colNameSpan.textContent = colName;
            listItem.appendChild(colNameSpan);

            const buttonsDiv = document.createElement('div');
            const upButton = document.createElement('button');
            upButton.textContent = '▲';
            upButton.style.marginLeft = '10px';
            upButton.style.cursor = 'pointer';
             upButton.onclick = () => moveColumnInList(colName, 'up');
            buttonsDiv.appendChild(upButton);

            const downButton = document.createElement('button');
            downButton.textContent = '▼';
            downButton.style.marginLeft = '5px';
            downButton.style.cursor = 'pointer';
             downButton.onclick = () => moveColumnInList(colName, 'down');
            buttonsDiv.appendChild(downButton);

            listItem.appendChild(buttonsDiv);
            list.appendChild(listItem);
        });

        document.getElementById('reorderPanel').style.display = 'block';
    }

    function hideReorderPanel() {
        document.getElementById('reorderPanel').style.display = 'none';
        // Optional: If you want to reset order on cancel, save a temp copy in showReorderPanel
        // For simplicity now, cancel just closes without resetting
    }

    function moveColumnInList(columnName, direction) {
        const oldIndex = columnDisplayOrder.indexOf(columnName);
        if (oldIndex === -1) return;

        let newIndex = oldIndex;
        if (direction === 'up' && oldIndex > 0) {
            newIndex = oldIndex - 1;
        } else if (direction === 'down' && oldIndex < columnDisplayOrder.length - 1) {
            newIndex = oldIndex + 1;
        } else {
            return; // Cannot move further
        }

        // Swap elements in the array
        const temp = columnDisplayOrder[oldIndex];
        columnDisplayOrder[oldIndex] = columnDisplayOrder[newIndex];
        columnDisplayOrder[newIndex] = temp;

        // Update the list display without recreating all elements (more efficient)
        const list = document.getElementById('columnOrderList');
        const items = Array.from(list.children); // Get current list items

        const movedItem = items[oldIndex];
        const targetItem = items[newIndex];

        if (direction === 'up') {
             list.insertBefore(movedItem, targetItem); // Insert moved before target
        } else { // direction === 'down'
             list.insertBefore(movedItem, targetItem.nextSibling); // Insert moved after target
        }
        // Re-attach event listeners if needed, but onclick is simple enough here
    }


    function applyReorder() {
        // columnDisplayOrder array is already updated by moveColumnInList
        hideReorderPanel();
        applyFilters(); // Re-render the table with the new order
    }


    // --- Column Width Adjustment Controls ---

    // Function to populate the column select dropdown for width adjustment
    function populateColumnWidthSelect() {
        const selectElement = document.getElementById('columnSelectForWidth');
        selectElement.innerHTML = '<option value="">- Select Column -</option>'; // Clear and add default

        // Use the list of columns from the uploaded file
        columnNamesFromExcel.forEach(colName => {
            const option = document.createElement('option');
            option.value = colName;
            option.textContent = colName;
            selectElement.appendChild(option);
        });

        // Reset width input and unit
        document.getElementById('columnWidthValue').value = 150; // Default value
        document.getElementById('columnWidthUnit').value = 'px'; // Default unit
    }

    // Function to apply the manually entered column width
    function applyColumnWidth() {
        const selectElement = document.getElementById('columnSelectForWidth');
        const columnName = selectElement.value;
        const widthValueInput = document.getElementById('columnWidthValue');
        const widthValue = parseFloat(widthValueInput.value);
        const widthUnit = document.getElementById('columnWidthUnit').value;

        if (!columnName) {
            alert("Please select a column first.");
            return;
        }
        if (isNaN(widthValue) || widthValue <= 0) {
            alert("Please enter a valid positive number for the width.");
            widthValueInput.focus();
            return;
        }

         // Find the actual column name from Excel header (case-insensitive) to use as key
         const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === columnName.toLowerCase());

        if (actualColumnName) {
            const widthString = `${widthValue}${widthUnit}`;
            columnWidths[actualColumnName] = widthString; // Store the width string

             // Re-apply filters to redraw the table with the new width
             applyFilters();
             alert(`Width of column "${actualColumnName}" set to ${widthString}.`);
        } else {
            alert(`Error: Could not find column "${columnName}" from Excel headers.`);
        }
    }

    // --- Column Alignment Adjustment Controls ---

     // Function to populate the column select dropdown for alignment adjustment
     function populateColumnAlignmentSelect() {
         const selectElement = document.getElementById('columnSelectForAlignment');
         selectElement.innerHTML = '<option value="">- Select Column -</option>'; // Clear and add default

         // Use the list of columns from the uploaded file
         columnNamesFromExcel.forEach(colName => {
             const option = document.createElement('option');
             option.value = colName;
             option.textContent = colName;
             selectElement.appendChild(option);
         });

         // Reset alignment select
         document.getElementById('columnAlignmentValue').value = 'left'; // Default alignment
     }

     // Function to apply the manually selected column alignment
     function applyColumnAlignment() {
         const selectElement = document.getElementById('columnSelectForAlignment');
         const columnName = selectElement.value;
         const alignmentValue = document.getElementById('columnAlignmentValue').value;

         if (!columnName) {
             alert("Please select a column first.");
             return;
         }

          // Find the actual column name from Excel header (case-insensitive) to use as key
          const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === columnName.toLowerCase());

         if (actualColumnName) {
             columnAlignments[actualColumnName] = alignmentValue; // Store the alignment string
             applyFilters(); // Re-render the table with the new alignment
             alert(`Alignment of column "${actualColumnName}" set to "${alignmentValue}".`);
         } else {
             alert(`Error: Could not find column "${columnName}" from Excel headers.`);
         }
     }


    // --- Layout Saving/Loading ---
    const LAYOUT_STORAGE_KEY = 'excelTableLayouts';


    function getSavedLayouts() {
        const layouts = localStorage.getItem(LAYOUT_STORAGE_KEY);
        return layouts ? JSON.parse(layouts) : {};
    }

    function saveLayout() {
        const layoutNameInput = document.getElementById('layoutNameInput');
        const layoutName = layoutNameInput.value.trim();
        if (!layoutName) {
            alert("Please enter a name for the layout.");
            return;
        }

        const savedLayouts = getSavedLayouts();

         // Store columnWidths, columnDisplayOrder, and columnAlignments as part of the layout state
        const currentLayoutState = {
            dataFilters: currentAppliedDataFilters,
            visibleColumns: visibleColumns,
            columnWidths: {...columnWidths}, // Save a copy of current widths
            columnDisplayOrder: [...columnDisplayOrder], // Save a copy of the current display order
            columnAlignments: {...columnAlignments} // Save a copy of current alignments
        };

        savedLayouts[layoutName] = currentLayoutState;
        localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(savedLayouts));

        alert(`Layout "${layoutName}" saved.`);
        layoutNameInput.value = ''; // Clear input
        loadSavedLayoutNames(); // Refresh dropdown
        enableLayoutButtons(); // Update button states
    }

    function loadLayout() {
        const selectElement = document.getElementById('loadLayoutSelect');
        const layoutName = selectElement.value;

        if (!layoutName) {
            alert("Please select a layout to load.");
            return;
        }

        const savedLayouts = getSavedLayouts();
        const layoutToLoad = savedLayouts[layoutName];

        if (layoutToLoad) {
             // Check if a file is loaded
             if (columnNamesFromExcel.length === 0) {
                 alert("Please upload an Excel file first before loading a layout.");
                 selectElement.value = ""; // Reset select
                 enableLayoutButtons();
                 return;
             }

             // Check if the columns in the saved layout roughly match the columns of the currently loaded file
             // This is a basic check; perfect matching might be complex with cleaned names
             const savedColumnNames = new Set();
             if (layoutToLoad.dataFilters) {
                 Object.keys(layoutToLoad.dataFilters).forEach(col => savedColumnNames.add(col.toLowerCase()));
             }
             if (layoutToLoad.visibleColumns) {
                 layoutToLoad.visibleColumns.forEach(col => savedColumnNames.add(col.toLowerCase()));
             }
              if (layoutToLoad.columnWidths) {
                  Object.keys(layoutToLoad.columnWidths).forEach(col => savedColumnNames.add(col.toLowerCase()));
              }
              if (layoutToLoad.columnDisplayOrder) {
                  layoutToLoad.columnDisplayOrder.forEach(col => savedColumnNames.add(col.toLowerCase()));
              }
              if (layoutToLoad.columnAlignments) { // Check for alignments
                   Object.keys(layoutToLoad.columnAlignments).forEach(col => savedColumnNames.add(col.toLowerCase()));
              }


             const currentFileColumnNamesLower = new Set(columnNamesFromExcel.map(name => name.toLowerCase()));

             const allSavedColumnsExist = Array.from(savedColumnNames).every(col => currentFileColumnNamesLower.has(col));


             if (!allSavedColumnsExist) {
                 alert(`Warning: The columns referenced in the saved layout "${layoutName}" do not fully match the columns in the current Excel file. Loading may result in unexpected filtering, column visibility, or widths/alignments for mismatched columns.`);
             }


            // Apply the loaded filters, visible columns, column widths, alignment, and display order
            currentAppliedDataFilters = layoutToLoad.dataFilters || {}; // Use empty object if undefined
            visibleColumns = layoutToLoad.visibleColumns || [...columnNamesFromExcel]; // Default to all if undefined
            columnWidths = layoutToLoad.columnWidths || {}; // Use empty object if undefined
            columnDisplayOrder = layoutToLoad.columnDisplayOrder || [...columnNamesFromExcel]; // Default to file order if undefined
            columnAlignments = layoutToLoad.columnAlignments || {}; // Use empty object if undefined


            // Ensure visibleColumns only contains columns present in the current file
             visibleColumns = visibleColumns.filter(col => columnNamesFromExcel.some(name => name.toLowerCase() === col.toLowerCase()));
             // If visibleColumns becomes empty after filtering, default to showing all if file has columns
             if (visibleColumns.length === 0 && columnNamesFromExcel.length > 0) {
                 visibleColumns = [...columnNamesFromExcel];
             }

             // Ensure columnDisplayOrder only contains columns present in the current file and add new ones
             const currentFileColumnNamesExact = new Set(columnNamesFromExcel);
             // Filter out saved columns that don't exist in the current file
             columnDisplayOrder = columnDisplayOrder.filter(col => currentFileColumnNamesExact.has(col));
             // Add any columns from the current file that were NOT in the saved layout's display order to the end
             currentFileColumnNamesExact.forEach(col => {
                 if (!columnDisplayOrder.includes(col)) {
                     columnDisplayOrder.push(col);
                 }
             });
             // If columnDisplayOrder becomes empty (shouldn't happen if file has columns), default to file order
             if (columnDisplayOrder.length === 0 && columnNamesFromExcel.length > 0) {
                 columnDisplayOrder = [...columnNamesFromExcel];
             }

             // Ensure columnAlignments only contains entries for columns present in the current file
             const loadedAlignments = layoutToLoad.columnAlignments || {};
             columnAlignments = {}; // Start fresh
             columnNamesFromExcel.forEach(col => {
                 // Find the key in the loaded alignments based on current file name (case-insensitive)
                 const loadedKey = Object.keys(loadedAlignments).find(key => key.toLowerCase() === col.toLowerCase());
                 if (loadedKey && ['left', 'center', 'right'].includes(loadedAlignments[loadedKey])) {
                     columnAlignments[col] = loadedAlignments[loadedKey]; // Use exact current column name as key
                 }
             });


            // Update the visual state of the filter dropdowns to match the loaded layout
            updateFilterDropdownsVisuals();

            // Apply the filters and update the table
            applyFilters();

            alert(`Layout "${layoutName}" loaded.`);
        } else {
            alert(`Layout "${layoutName}" not found.`);
        }
    }

     function deleteLayout() {
         const selectElement = document.getElementById('loadLayoutSelect');
         const layoutName = selectElement.value;

         if (!layoutName) {
             alert("Please select a layout to delete.");
             return;
         }

         if (confirm(`Are you sure you want to delete the layout "${layoutName}"?`)) {
             const savedLayouts = getSavedLayouts();
             delete savedLayouts[layoutName];
             localStorage.setItem(LAYOUT_STORAGE_KEY, JSON.stringify(savedLayouts));
             alert(`Layout "${layoutName}" deleted.`);
             loadSavedLayoutNames(); // Refresh dropdown
             enableLayoutButtons(); // Update button states
         }
     }

    function loadSavedLayoutNames() {
        const selectElement = document.getElementById('loadLayoutSelect');
        selectElement.innerHTML = '<option value="">- Load Layout -</option>'; // Clear and add default

        const savedLayouts = getSavedLayouts();
        for (const name in savedLayouts) {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            selectElement.appendChild(option);
        }
        enableLayoutButtons(); // Update button states
    }

     function enableLayoutButtons() {
         const selectElement = document.getElementById('loadLayoutSelect');
         const loadButton = document.getElementById('loadLayoutButton');
         const deleteButton = document.getElementById('deleteLayoutButton');
         const layoutNameInput = document.getElementById('layoutNameInput');
         const saveButton = document.getElementById('saveLayoutButton');


         const isLayoutSelected = selectElement.value !== "";
         loadButton.disabled = !isLayoutSelected;
         deleteButton.disabled = !isLayoutSelected;

          // Enable save button only if a name is entered AND a file is loaded
         saveButton.disabled = layoutNameInput.value.trim() === "" || columnNamesFromExcel.length === 0;
          // Update save button state when input changes
         layoutNameInput.removeEventListener('input', handleLayoutNameInput); // Prevent adding multiple listeners
         layoutNameInput.addEventListener('input', handleLayoutNameInput);

     }

     function handleLayoutNameInput() {
         const layoutNameInput = document.getElementById('layoutNameInput');
         const saveButton = document.getElementById('saveLayoutButton');
          saveButton.disabled = layoutNameInput.value.trim() === "" || columnNamesFromExcel.length === 0;
     }


    // Function to update the visual state of filter dropdowns to match currentAppliedDataFilters and visibleColumns
    function updateFilterDropdownsVisuals() {
        // Update Data Filter dropdowns
        document.querySelectorAll('.filter-dropdown[data-filter-type="data"]').forEach(dropdown => {
            const columnName = dropdown.getAttribute('data-column');
            const selectedValues = currentAppliedDataFilters[columnName] || [];
            const optionsContainer = dropdown.querySelector('.filter-options');
            const selectAllCheckbox = dropdown.querySelector('.select-all-checkbox');

            optionsContainer.querySelectorAll('.filter-checkbox').forEach(checkbox => {
                checkbox.checked = selectedValues.includes(checkbox.value);
            });
            updateSelectAllCheckbox(optionsContainer, selectAllCheckbox); // Update select all state
        });

        // Update Column Visibility dropdown
        const visibilityDropdown = document.querySelector('.filter-dropdown[data-filter-type="visibility"]');
        if (visibilityDropdown) {
             const optionsContainer = visibilityDropdown.querySelector('.filter-options');
             const selectAllCheckbox = visibilityDropdown.querySelector('.select-all-columns-checkbox');

             optionsContainer.querySelectorAll('.column-checkbox').forEach(checkbox => {
                 checkbox.checked = visibleColumns.includes(checkbox.value);
             });
             updateSelectAllCheckbox(optionsContainer, selectAllCheckbox); // Update select all state
        }
         // Note: Column width input/select are updated in populateColumnWidthSelect
         // Alignment select is updated in populateColumnAlignmentSelect
    }


    // --- Download Functionality ---

    function downloadExcel() {
        // Get the data currently displayed in the table (filtered data)
        let filteredData = tableData; // Start with all data

         // Apply data filters first
        dataFilterableColumnNames.forEach(columnName => {
            const selectedValues = currentAppliedDataFilters[columnName]; // Use currently applied data filters
            if (selectedValues && selectedValues.length > 0) {
                filteredData = filteredData.filter(row => {
                     // Find the actual key in the row object based on the filter column name (case-insensitive)
                     const rowKey = Object.keys(row).find(key => key.toLowerCase() === columnName.toLowerCase());
                     if (rowKey) {
                         const rowValue = row[rowKey] !== undefined && row[rowKey] !== null ? String(row[rowKey]) : '';
                         return selectedValues.includes(rowValue);
                     }
                     return false;
                });
            }
        });

        // Apply sorting to filtered data for Excel download as well (optional, but consistent)
         if (currentSort.column) {
             const sortColumnName = currentSort.column;
             const sortDirection = currentSort.direction;
              const actualSortColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === sortColumnName.toLowerCase());
             if (actualSortColumnName) {
                 filteredData.sort((a, b) => {
                     const aValue = a[actualSortColumnName] !== undefined && a[actualSortColumnName] !== null ? String(a[actualSortColumnName]) : '';
                     const bValue = b[actualSortColumnName] !== undefined && b[actualSortColumnName] !== null ? String(b[actualSortColumnName]) : '';
                      // Special handling for month columns for sorting
                      if (actualSortColumnName.toLowerCase() === 'receive month' || actualSortColumnName.toLowerCase() === 'mfg month') {
                           const numA = parseInt(aValue);
                           const numB = parseInt(bValue);
                            if (isNaN(numA) && isNaN(numB)) return 0;
                            if (isNaN(numA)) return 1;
                            if (isNaN(numB)) return -1;
                            return sortDirection === 'asc' ? numA - numB : numB - numA; // Use numB - numA for desc
                      }
                     if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
                     if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
                     return 0;
                 });
             }
         }


        // Now extract data only for visible columns based on the current display order
        const dataToDownload = [];

        // Add headers for visible columns, using actual column names for better representation in Excel, respecting display order
        const headersToDownload = [];
        columnDisplayOrder.forEach(col => {
             if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                  // Find the corresponding actual column name from Excel header (case-insensitive)
                  const actualColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                  headersToDownload.push(actualColumnName || col); // Use actual if found, fallback to processed
             }
        });
        dataToDownload.push(headersToDownload);

        // Add row data for visible columns, respecting display order
        filteredData.forEach(row => {
            const rowArray = [];
            columnDisplayOrder.forEach(col => {
                 if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                     // Find the actual key in the row object based on the column name from display order (case-insensitive)
                     const rowKey = Object.keys(row).find(key => key.toLowerCase() === col.toLowerCase());
                     rowArray.push(rowKey ? row[rowKey] : ''); // Use row[rowKey] directly
                 }
            });
            dataToDownload.push(rowArray);
        });


         if (dataToDownload.length <= 1) { // Only header row or no data
             alert("No data to download based on current filters and column selections.");
             return;
         }

        // Create a new workbook and worksheet
        const ws = XLSX.utils.aoa_to_sheet(dataToDownload);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "FilteredTable"); // Sheet name
        wb.Props = {
            Title: "Filtered Table Data",
            Subject: "Table Data Download",
            Author: "Web Page Script",
            CreatedDate: new Date()
        };


        // Write and download the file
        XLSX.writeFile(wb, "table_data.xlsx");
    }

    // Replace your existing downloadPdf function with this corrected version
    function downloadPdf() {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('l', 'pt', 'a4'); // Landscape A4

        // Data for autoTable - get filtered and sorted data (reuse logic from applyFilters)
        let filteredData = tableData;
         // Apply data filters
        dataFilterableColumnNames.forEach(columnName => {
            const selectedValues = currentAppliedDataFilters[columnName];
            if (selectedValues && selectedValues.length > 0) {
                filteredData = filteredData.filter(row => {
                     const rowKey = Object.keys(row).find(key => key.toLowerCase() === columnName.toLowerCase());
                     if (rowKey) {
                         const rowValue = row[rowKey] !== undefined && row[rowKey] !== null ? String(row[rowKey]) : '';
                         return selectedValues.includes(rowValue);
                     }
                     return false;
                });
            }
        });
        // Apply sorting to filtered data
         if (currentSort.column) {
             const sortColumnName = currentSort.column;
             const sortDirection = currentSort.direction;
              const actualSortColumnName = columnNamesFromExcel.find(name => name.toLowerCase() === sortColumnName.toLowerCase());
             if (actualSortColumnName) {
                 filteredData.sort((a, b) => {
                     const aValue = a[actualSortColumnName] !== undefined && a[actualSortColumnName] !== null ? String(a[actualSortColumnName]) : '';
                     const bValue = b[actualSortColumnName] !== undefined && b[actualSortColumnName] !== null ? String(b[actualSortColumnName]) : '';
                      // Special handling for month columns for sorting
                      if (actualSortColumnName.toLowerCase() === 'receive month' || actualSortColumnName.toLowerCase() === 'mfg month') {
                           const numA = parseInt(aValue);
                           const numB = parseInt(bValue);
                            if (isNaN(numA) && isNaN(numB)) return 0;
                            if (isNaN(numA)) return 1;
                            if (isNaN(numB)) return -1;
                            return sortDirection === 'asc' ? numA - numB : numB - numA;
                      }
                     if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
                     if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
                     return 0;
                 });
             }
         }


        // Prepare table headers and rows based on visible columns and display order
        const pdfHeaders = [];
        const pdfRows = [];
        const columnStyles = {}; // To store alignment and potential width hints for autoTable

        // Headers - iterate columnDisplayOrder, check visibility
        let colIndex = 0;
        columnDisplayOrder.forEach(col => {
             if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                 pdfHeaders.push(col); // Use the column name from display order for the header

                  // Apply header alignment from columnAlignments
                  const actualColName = columnNamesFromExcel.find(name => name.toLowerCase() === col.toLowerCase());
                  const headerAlignment = actualColName ? columnAlignments[actualColName] : 'left'; // Default header alignment to left
                   columnStyles[colIndex] = { halign: headerAlignment, valign: 'top' }; // Apply to autoTable headStyles later

                   // Try to apply column widths to autoTable
                    if (actualColName && columnWidths[actualColName]) {
                         const widthStr = columnWidths[actualColName];
                         if (widthStr.endsWith('px')) {
                              // Convert px to points (assuming 1px = 0.75pt)
                              const widthInPoints = parseFloat(widthStr) * 0.75;
                               columnStyles[colIndex].cellWidth = widthInPoints;
                         }
                         // autoTable handles % widths relatively well on its own
                         // For other units, you might need a more complex conversion or let autoTable handle it
                    }


                 colIndex++; // Increment index only for visible columns
             }
        });

        // Rows - iterate filteredData, then columnDisplayOrder, check visibility
        filteredData.forEach(rowData => {
            const rowArray = [];
            columnDisplayOrder.forEach(col => {
                if (visibleColumns.some(visibleCol => visibleCol.toLowerCase() === col.toLowerCase())) {
                     // Find the actual key in the row object based on the column name from display order (case-insensitive)
                     const rowKey = Object.keys(rowData).find(key => key.toLowerCase() === col.toLowerCase());
                     rowArray.push(rowKey ? rowData[rowKey] : ''); // Use rowData[rowKey] directly
                }
            });
            pdfRows.push(rowArray);
        });

         if (pdfHeaders.length === 0 || pdfRows.length === 0) {
             alert("No data or visible columns to download as PDF.");
             return;
         }

        // Get remarks for PDF (which will act as the title)
         const remarks = document.getElementById('pdfRemarksInput').value.trim();

         // Calculate required height for the header area (Company Name + Remarks + padding)
         const margin = 40;
         const pdfWidth = pdf.internal.pageSize.getWidth();
         const companyNameHeightEst = 16 * 1.2; // Estimate height of Company Name text (font size * line spacing factor)
         const remarksLineHeightEst = 14 * 1.2; // Estimate height of one line of remarks text
         let remarksBlockHeight = 0;
         if (remarks) {
             const splitRemarks = pdf.splitTextToSize(remarks, pdfWidth - 2 * margin);
             remarksBlockHeight = splitRemarks.length * remarksLineHeightEst;
         }
         // Add padding: 15 after Company Name, 20 after Remarks before table
         const paddingAfterCompanyName = 15;
         const paddingAfterRemarks = 20;

         let headerHeightPt = margin + companyNameHeightEst + paddingAfterCompanyName + remarksBlockHeight + paddingAfterRemarks;

         // Ensure minimum space if no remarks
         if (!remarks) {
             headerHeightPt = margin + companyNameHeightEst + paddingAfterCompanyName + paddingAfterRemarks;
         }

         // Add some extra safety padding if needed, or adjust the padding values above
         headerHeightPt += 10; // Add a little extra safety margin


        // *** Add this specific headStyle override for the first column ***
         const firstColumnIndex = 0; // The index of the first column in pdfHeaders/pdfRows
         if (pdfHeaders.length > 0) {
             if (!columnStyles[firstColumnIndex]) {
                 columnStyles[firstColumnIndex] = {};
             }
             // Explicitly set halign for the first column header in headStyles
             // Use the same alignment as the cell alignment or default to left
             columnStyles[firstColumnIndex].headStyles = { halign: columnStyles[firstColumnIndex].halign || 'left' };
         }
        // *************************************************************


        pdf.autoTable({
            head: [pdfHeaders],
            body: pdfRows,
            // Set startY to the calculated header height to ensure the table starts below it on the first page
            startY: headerHeightPt,
            theme: 'grid',
            headStyles: {
                 fillColor: '#e0f7fa', // Light blue header background
                 textColor: '#333',
                 fontStyle: 'bold',
                 halign: 'center', // Default header text alignment for all headers
                 valign: 'top'
            },
             bodyStyles: {
                 textColor: '#333',
                 valign: 'top'
                 // halign is applied per column in columnStyles
             },
             alternateRowStyles: {
                 fillColor: '#f5f5f5' // Light gray for alternate rows (optional, but nice)
             },
            columnStyles: columnStyles, // Apply stored column styles (width and alignment)
            tableWidth: 'auto', // Make table fill page width
            margin: { top: headerHeightPt, bottom: 40, left: 40, right: 40 }, // Set margin.top to the calculated header height
            // didDrawPage will now draw header content within the top margin area
            didDrawPage: function(data) {
                 const pageMargin = 40; // Use the same margin value as used for table margin
                 const pdfWidth = pdf.internal.pageSize.getWidth();
                 const pdfHeight = pdf.internal.pageSize.getHeight();

                // Company Name (Draw within the top margin)
                pdf.setFontSize(16);
                pdf.setTextColor('#000080');
                const companyNameY = pageMargin + 15; // Position below top page margin + some padding
                pdf.text('Sagar Manufacturers Pvt. Ltd.', pageMargin, companyNameY);

                 // Add remarks (acting as title) if present, below the company name
                 if (remarks) {
                     const companyNameBottom = companyNameY + (16 * 1.2); // Estimate bottom of company name text
                     const remarksYPos = companyNameBottom + 10; // Position below company name + padding
                     pdf.setFontSize(14); // Use title font size for remarks
                     pdf.setTextColor('#333'); // Use title color
                     const splitRemarks = pdf.splitTextToSize(remarks, pdfWidth - 2 * pageMargin);
                      // Center remarks horizontally
                     const remarksTextWidth = pdf.getTextWidth(splitRemarks[0] || ''); // Get width of the first line for centering
                     const centerX = (pdfWidth - remarksTextWidth) / 2;
                     pdf.text(splitRemarks, centerX, remarksYPos); // Add remarks text
                 }

                // Add page number at the bottom
                 pdf.setFontSize(10);
                 pdf.setTextColor(150);
                 // Position page number relative to the bottom margin
                 pdf.text('Page ' + data.pageNumber, pdfWidth - pageMargin, pdfHeight - pageMargin, { align: 'right' });
             }
            // didParseData is not needed
        });

        pdf.save("complaint_dashboard.pdf");
    }

</script>

</body>
</html>
